
freeRTOS_1280_v0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800200  00000ffe  00001092  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ffe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000665  00800214  00800214  000010a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000010a6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000010d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000290  00000000  00000000  00001118  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003260  00000000  00000000  000013a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012a6  00000000  00000000  00004608  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b73  00000000  00000000  000058ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000858  00000000  00000000  00007424  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000122c  00000000  00000000  00007c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025ea  00000000  00000000  00008ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000b492  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	8c c0       	rjmp	.+280    	; 0x11e <__bad_interrupt>
   6:	00 00       	nop
   8:	8a c0       	rjmp	.+276    	; 0x11e <__bad_interrupt>
   a:	00 00       	nop
   c:	88 c0       	rjmp	.+272    	; 0x11e <__bad_interrupt>
   e:	00 00       	nop
  10:	86 c0       	rjmp	.+268    	; 0x11e <__bad_interrupt>
  12:	00 00       	nop
  14:	84 c0       	rjmp	.+264    	; 0x11e <__bad_interrupt>
  16:	00 00       	nop
  18:	82 c0       	rjmp	.+260    	; 0x11e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	80 c0       	rjmp	.+256    	; 0x11e <__bad_interrupt>
  1e:	00 00       	nop
  20:	7e c0       	rjmp	.+252    	; 0x11e <__bad_interrupt>
  22:	00 00       	nop
  24:	7c c0       	rjmp	.+248    	; 0x11e <__bad_interrupt>
  26:	00 00       	nop
  28:	7a c0       	rjmp	.+244    	; 0x11e <__bad_interrupt>
  2a:	00 00       	nop
  2c:	78 c0       	rjmp	.+240    	; 0x11e <__bad_interrupt>
  2e:	00 00       	nop
  30:	76 c0       	rjmp	.+236    	; 0x11e <__bad_interrupt>
  32:	00 00       	nop
  34:	74 c0       	rjmp	.+232    	; 0x11e <__bad_interrupt>
  36:	00 00       	nop
  38:	72 c0       	rjmp	.+228    	; 0x11e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	70 c0       	rjmp	.+224    	; 0x11e <__bad_interrupt>
  3e:	00 00       	nop
  40:	6e c0       	rjmp	.+220    	; 0x11e <__bad_interrupt>
  42:	00 00       	nop
  44:	61 c2       	rjmp	.+1218   	; 0x508 <__vector_17>
  46:	00 00       	nop
  48:	6a c0       	rjmp	.+212    	; 0x11e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	68 c0       	rjmp	.+208    	; 0x11e <__bad_interrupt>
  4e:	00 00       	nop
  50:	66 c0       	rjmp	.+204    	; 0x11e <__bad_interrupt>
  52:	00 00       	nop
  54:	64 c0       	rjmp	.+200    	; 0x11e <__bad_interrupt>
  56:	00 00       	nop
  58:	62 c0       	rjmp	.+196    	; 0x11e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	60 c0       	rjmp	.+192    	; 0x11e <__bad_interrupt>
  5e:	00 00       	nop
  60:	5e c0       	rjmp	.+188    	; 0x11e <__bad_interrupt>
  62:	00 00       	nop
  64:	5c c0       	rjmp	.+184    	; 0x11e <__bad_interrupt>
  66:	00 00       	nop
  68:	5a c0       	rjmp	.+180    	; 0x11e <__bad_interrupt>
  6a:	00 00       	nop
  6c:	58 c0       	rjmp	.+176    	; 0x11e <__bad_interrupt>
  6e:	00 00       	nop
  70:	56 c0       	rjmp	.+172    	; 0x11e <__bad_interrupt>
  72:	00 00       	nop
  74:	54 c0       	rjmp	.+168    	; 0x11e <__bad_interrupt>
  76:	00 00       	nop
  78:	52 c0       	rjmp	.+164    	; 0x11e <__bad_interrupt>
  7a:	00 00       	nop
  7c:	50 c0       	rjmp	.+160    	; 0x11e <__bad_interrupt>
  7e:	00 00       	nop
  80:	4e c0       	rjmp	.+156    	; 0x11e <__bad_interrupt>
  82:	00 00       	nop
  84:	4c c0       	rjmp	.+152    	; 0x11e <__bad_interrupt>
  86:	00 00       	nop
  88:	4a c0       	rjmp	.+148    	; 0x11e <__bad_interrupt>
  8a:	00 00       	nop
  8c:	48 c0       	rjmp	.+144    	; 0x11e <__bad_interrupt>
  8e:	00 00       	nop
  90:	46 c0       	rjmp	.+140    	; 0x11e <__bad_interrupt>
  92:	00 00       	nop
  94:	44 c0       	rjmp	.+136    	; 0x11e <__bad_interrupt>
  96:	00 00       	nop
  98:	42 c0       	rjmp	.+132    	; 0x11e <__bad_interrupt>
  9a:	00 00       	nop
  9c:	40 c0       	rjmp	.+128    	; 0x11e <__bad_interrupt>
  9e:	00 00       	nop
  a0:	3e c0       	rjmp	.+124    	; 0x11e <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3c c0       	rjmp	.+120    	; 0x11e <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3a c0       	rjmp	.+116    	; 0x11e <__bad_interrupt>
  aa:	00 00       	nop
  ac:	38 c0       	rjmp	.+112    	; 0x11e <__bad_interrupt>
  ae:	00 00       	nop
  b0:	36 c0       	rjmp	.+108    	; 0x11e <__bad_interrupt>
  b2:	00 00       	nop
  b4:	34 c0       	rjmp	.+104    	; 0x11e <__bad_interrupt>
  b6:	00 00       	nop
  b8:	32 c0       	rjmp	.+100    	; 0x11e <__bad_interrupt>
  ba:	00 00       	nop
  bc:	30 c0       	rjmp	.+96     	; 0x11e <__bad_interrupt>
  be:	00 00       	nop
  c0:	2e c0       	rjmp	.+92     	; 0x11e <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2c c0       	rjmp	.+88     	; 0x11e <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2a c0       	rjmp	.+84     	; 0x11e <__bad_interrupt>
  ca:	00 00       	nop
  cc:	28 c0       	rjmp	.+80     	; 0x11e <__bad_interrupt>
  ce:	00 00       	nop
  d0:	26 c0       	rjmp	.+76     	; 0x11e <__bad_interrupt>
  d2:	00 00       	nop
  d4:	24 c0       	rjmp	.+72     	; 0x11e <__bad_interrupt>
  d6:	00 00       	nop
  d8:	22 c0       	rjmp	.+68     	; 0x11e <__bad_interrupt>
  da:	00 00       	nop
  dc:	20 c0       	rjmp	.+64     	; 0x11e <__bad_interrupt>
  de:	00 00       	nop
  e0:	1e c0       	rjmp	.+60     	; 0x11e <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61

000000f0 <__do_copy_data>:
  f0:	12 e0       	ldi	r17, 0x02	; 2
  f2:	a0 e0       	ldi	r26, 0x00	; 0
  f4:	b2 e0       	ldi	r27, 0x02	; 2
  f6:	ee ef       	ldi	r30, 0xFE	; 254
  f8:	ff e0       	ldi	r31, 0x0F	; 15
  fa:	00 e0       	ldi	r16, 0x00	; 0
  fc:	0b bf       	out	0x3b, r16	; 59
  fe:	02 c0       	rjmp	.+4      	; 0x104 <__do_copy_data+0x14>
 100:	07 90       	elpm	r0, Z+
 102:	0d 92       	st	X+, r0
 104:	a4 31       	cpi	r26, 0x14	; 20
 106:	b1 07       	cpc	r27, r17
 108:	d9 f7       	brne	.-10     	; 0x100 <__do_copy_data+0x10>

0000010a <__do_clear_bss>:
 10a:	28 e0       	ldi	r18, 0x08	; 8
 10c:	a4 e1       	ldi	r26, 0x14	; 20
 10e:	b2 e0       	ldi	r27, 0x02	; 2
 110:	01 c0       	rjmp	.+2      	; 0x114 <.do_clear_bss_start>

00000112 <.do_clear_bss_loop>:
 112:	1d 92       	st	X+, r1

00000114 <.do_clear_bss_start>:
 114:	a9 37       	cpi	r26, 0x79	; 121
 116:	b2 07       	cpc	r27, r18
 118:	e1 f7       	brne	.-8      	; 0x112 <.do_clear_bss_loop>
 11a:	cb d6       	rcall	.+3478   	; 0xeb2 <main>
 11c:	6e c7       	rjmp	.+3804   	; 0xffa <_exit>

0000011e <__bad_interrupt>:
 11e:	70 cf       	rjmp	.-288    	; 0x0 <__vectors>

00000120 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 120:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 122:	03 96       	adiw	r24, 0x03	; 3
 124:	92 83       	std	Z+2, r25	; 0x02
 126:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 128:	4f ef       	ldi	r20, 0xFF	; 255
 12a:	5f ef       	ldi	r21, 0xFF	; 255
 12c:	ba 01       	movw	r22, r20
 12e:	43 83       	std	Z+3, r20	; 0x03
 130:	54 83       	std	Z+4, r21	; 0x04
 132:	65 83       	std	Z+5, r22	; 0x05
 134:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 136:	90 87       	std	Z+8, r25	; 0x08
 138:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 13a:	92 87       	std	Z+10, r25	; 0x0a
 13c:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 13e:	10 82       	st	Z, r1
 140:	08 95       	ret

00000142 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 142:	fc 01       	movw	r30, r24
 144:	13 86       	std	Z+11, r1	; 0x0b
 146:	12 86       	std	Z+10, r1	; 0x0a
 148:	08 95       	ret

0000014a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
 14e:	9c 01       	movw	r18, r24
 150:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 152:	dc 01       	movw	r26, r24
 154:	11 96       	adiw	r26, 0x01	; 1
 156:	cd 91       	ld	r28, X+
 158:	dc 91       	ld	r29, X
 15a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 15c:	d5 83       	std	Z+5, r29	; 0x05
 15e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 160:	8e 81       	ldd	r24, Y+6	; 0x06
 162:	9f 81       	ldd	r25, Y+7	; 0x07
 164:	97 83       	std	Z+7, r25	; 0x07
 166:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 168:	8e 81       	ldd	r24, Y+6	; 0x06
 16a:	9f 81       	ldd	r25, Y+7	; 0x07
 16c:	dc 01       	movw	r26, r24
 16e:	15 96       	adiw	r26, 0x05	; 5
 170:	7c 93       	st	X, r23
 172:	6e 93       	st	-X, r22
 174:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
 176:	7f 83       	std	Y+7, r23	; 0x07
 178:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 17a:	33 87       	std	Z+11, r19	; 0x0b
 17c:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
 17e:	f9 01       	movw	r30, r18
 180:	80 81       	ld	r24, Z
 182:	8f 5f       	subi	r24, 0xFF	; 255
 184:	80 83       	st	Z, r24
}
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	08 95       	ret

0000018c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 18c:	0f 93       	push	r16
 18e:	1f 93       	push	r17
 190:	cf 93       	push	r28
 192:	df 93       	push	r29
 194:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 196:	08 81       	ld	r16, Y
 198:	19 81       	ldd	r17, Y+1	; 0x01
 19a:	2a 81       	ldd	r18, Y+2	; 0x02
 19c:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 19e:	0f 3f       	cpi	r16, 0xFF	; 255
 1a0:	4f ef       	ldi	r20, 0xFF	; 255
 1a2:	14 07       	cpc	r17, r20
 1a4:	24 07       	cpc	r18, r20
 1a6:	34 07       	cpc	r19, r20
 1a8:	21 f4       	brne	.+8      	; 0x1b2 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1aa:	fc 01       	movw	r30, r24
 1ac:	a1 85       	ldd	r26, Z+9	; 0x09
 1ae:	b2 85       	ldd	r27, Z+10	; 0x0a
 1b0:	11 c0       	rjmp	.+34     	; 0x1d4 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 1b2:	dc 01       	movw	r26, r24
 1b4:	13 96       	adiw	r26, 0x03	; 3
 1b6:	01 c0       	rjmp	.+2      	; 0x1ba <vListInsert+0x2e>
 1b8:	df 01       	movw	r26, r30
 1ba:	14 96       	adiw	r26, 0x04	; 4
 1bc:	ed 91       	ld	r30, X+
 1be:	fc 91       	ld	r31, X
 1c0:	15 97       	sbiw	r26, 0x05	; 5
 1c2:	40 81       	ld	r20, Z
 1c4:	51 81       	ldd	r21, Z+1	; 0x01
 1c6:	62 81       	ldd	r22, Z+2	; 0x02
 1c8:	73 81       	ldd	r23, Z+3	; 0x03
 1ca:	04 17       	cp	r16, r20
 1cc:	15 07       	cpc	r17, r21
 1ce:	26 07       	cpc	r18, r22
 1d0:	37 07       	cpc	r19, r23
 1d2:	90 f7       	brcc	.-28     	; 0x1b8 <vListInsert+0x2c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d4:	14 96       	adiw	r26, 0x04	; 4
 1d6:	ed 91       	ld	r30, X+
 1d8:	fc 91       	ld	r31, X
 1da:	15 97       	sbiw	r26, 0x05	; 5
 1dc:	fd 83       	std	Y+5, r31	; 0x05
 1de:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1e0:	d7 83       	std	Z+7, r29	; 0x07
 1e2:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
 1e4:	bf 83       	std	Y+7, r27	; 0x07
 1e6:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
 1e8:	15 96       	adiw	r26, 0x05	; 5
 1ea:	dc 93       	st	X, r29
 1ec:	ce 93       	st	-X, r28
 1ee:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 1f0:	9b 87       	std	Y+11, r25	; 0x0b
 1f2:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
 1f4:	fc 01       	movw	r30, r24
 1f6:	20 81       	ld	r18, Z
 1f8:	2f 5f       	subi	r18, 0xFF	; 255
 1fa:	20 83       	st	Z, r18
}
 1fc:	df 91       	pop	r29
 1fe:	cf 91       	pop	r28
 200:	1f 91       	pop	r17
 202:	0f 91       	pop	r16
 204:	08 95       	ret

00000206 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 206:	cf 93       	push	r28
 208:	df 93       	push	r29
 20a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 20c:	a2 85       	ldd	r26, Z+10	; 0x0a
 20e:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 210:	c4 81       	ldd	r28, Z+4	; 0x04
 212:	d5 81       	ldd	r29, Z+5	; 0x05
 214:	86 81       	ldd	r24, Z+6	; 0x06
 216:	97 81       	ldd	r25, Z+7	; 0x07
 218:	9f 83       	std	Y+7, r25	; 0x07
 21a:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 21c:	c6 81       	ldd	r28, Z+6	; 0x06
 21e:	d7 81       	ldd	r29, Z+7	; 0x07
 220:	84 81       	ldd	r24, Z+4	; 0x04
 222:	95 81       	ldd	r25, Z+5	; 0x05
 224:	9d 83       	std	Y+5, r25	; 0x05
 226:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 228:	11 96       	adiw	r26, 0x01	; 1
 22a:	8d 91       	ld	r24, X+
 22c:	9c 91       	ld	r25, X
 22e:	12 97       	sbiw	r26, 0x02	; 2
 230:	e8 17       	cp	r30, r24
 232:	f9 07       	cpc	r31, r25
 234:	31 f4       	brne	.+12     	; 0x242 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 236:	86 81       	ldd	r24, Z+6	; 0x06
 238:	97 81       	ldd	r25, Z+7	; 0x07
 23a:	12 96       	adiw	r26, 0x02	; 2
 23c:	9c 93       	st	X, r25
 23e:	8e 93       	st	-X, r24
 240:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 242:	13 86       	std	Z+11, r1	; 0x0b
 244:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
 246:	8c 91       	ld	r24, X
 248:	81 50       	subi	r24, 0x01	; 1
 24a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 24c:	8c 91       	ld	r24, X
}
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	08 95       	ret

00000254 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 254:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 258:	8c e7       	ldi	r24, 0x7C	; 124
 25a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 25e:	8b e0       	ldi	r24, 0x0B	; 11
 260:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 264:	ef e6       	ldi	r30, 0x6F	; 111
 266:	f0 e0       	ldi	r31, 0x00	; 0
 268:	80 81       	ld	r24, Z
 26a:	82 60       	ori	r24, 0x02	; 2
 26c:	80 83       	st	Z, r24
 26e:	08 95       	ret

00000270 <pxPortInitialiseStack>:
 270:	31 e1       	ldi	r19, 0x11	; 17
 272:	fc 01       	movw	r30, r24
 274:	30 83       	st	Z, r19
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	22 e2       	ldi	r18, 0x22	; 34
 27a:	20 83       	st	Z, r18
 27c:	31 97       	sbiw	r30, 0x01	; 1
 27e:	a3 e3       	ldi	r26, 0x33	; 51
 280:	a0 83       	st	Z, r26
 282:	31 97       	sbiw	r30, 0x01	; 1
 284:	60 83       	st	Z, r22
 286:	31 97       	sbiw	r30, 0x01	; 1
 288:	70 83       	st	Z, r23
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	10 82       	st	Z, r1
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	60 e8       	ldi	r22, 0x80	; 128
 292:	60 83       	st	Z, r22
 294:	31 97       	sbiw	r30, 0x01	; 1
 296:	10 82       	st	Z, r1
 298:	31 97       	sbiw	r30, 0x01	; 1
 29a:	62 e0       	ldi	r22, 0x02	; 2
 29c:	60 83       	st	Z, r22
 29e:	31 97       	sbiw	r30, 0x01	; 1
 2a0:	63 e0       	ldi	r22, 0x03	; 3
 2a2:	60 83       	st	Z, r22
 2a4:	31 97       	sbiw	r30, 0x01	; 1
 2a6:	64 e0       	ldi	r22, 0x04	; 4
 2a8:	60 83       	st	Z, r22
 2aa:	31 97       	sbiw	r30, 0x01	; 1
 2ac:	65 e0       	ldi	r22, 0x05	; 5
 2ae:	60 83       	st	Z, r22
 2b0:	31 97       	sbiw	r30, 0x01	; 1
 2b2:	66 e0       	ldi	r22, 0x06	; 6
 2b4:	60 83       	st	Z, r22
 2b6:	31 97       	sbiw	r30, 0x01	; 1
 2b8:	67 e0       	ldi	r22, 0x07	; 7
 2ba:	60 83       	st	Z, r22
 2bc:	31 97       	sbiw	r30, 0x01	; 1
 2be:	68 e0       	ldi	r22, 0x08	; 8
 2c0:	60 83       	st	Z, r22
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	69 e0       	ldi	r22, 0x09	; 9
 2c6:	60 83       	st	Z, r22
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	60 e1       	ldi	r22, 0x10	; 16
 2cc:	60 83       	st	Z, r22
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	30 83       	st	Z, r19
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	32 e1       	ldi	r19, 0x12	; 18
 2d6:	30 83       	st	Z, r19
 2d8:	31 97       	sbiw	r30, 0x01	; 1
 2da:	33 e1       	ldi	r19, 0x13	; 19
 2dc:	30 83       	st	Z, r19
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	34 e1       	ldi	r19, 0x14	; 20
 2e2:	30 83       	st	Z, r19
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	35 e1       	ldi	r19, 0x15	; 21
 2e8:	30 83       	st	Z, r19
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	36 e1       	ldi	r19, 0x16	; 22
 2ee:	30 83       	st	Z, r19
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	37 e1       	ldi	r19, 0x17	; 23
 2f4:	30 83       	st	Z, r19
 2f6:	31 97       	sbiw	r30, 0x01	; 1
 2f8:	38 e1       	ldi	r19, 0x18	; 24
 2fa:	30 83       	st	Z, r19
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	39 e1       	ldi	r19, 0x19	; 25
 300:	30 83       	st	Z, r19
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	30 e2       	ldi	r19, 0x20	; 32
 306:	30 83       	st	Z, r19
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	31 e2       	ldi	r19, 0x21	; 33
 30c:	30 83       	st	Z, r19
 30e:	31 97       	sbiw	r30, 0x01	; 1
 310:	20 83       	st	Z, r18
 312:	31 97       	sbiw	r30, 0x01	; 1
 314:	23 e2       	ldi	r18, 0x23	; 35
 316:	20 83       	st	Z, r18
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	40 83       	st	Z, r20
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	50 83       	st	Z, r21
 320:	31 97       	sbiw	r30, 0x01	; 1
 322:	26 e2       	ldi	r18, 0x26	; 38
 324:	20 83       	st	Z, r18
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	27 e2       	ldi	r18, 0x27	; 39
 32a:	20 83       	st	Z, r18
 32c:	31 97       	sbiw	r30, 0x01	; 1
 32e:	28 e2       	ldi	r18, 0x28	; 40
 330:	20 83       	st	Z, r18
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	29 e2       	ldi	r18, 0x29	; 41
 336:	20 83       	st	Z, r18
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	20 e3       	ldi	r18, 0x30	; 48
 33c:	20 83       	st	Z, r18
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	21 e3       	ldi	r18, 0x31	; 49
 342:	20 83       	st	Z, r18
 344:	86 97       	sbiw	r24, 0x26	; 38
 346:	08 95       	ret

00000348 <xPortStartScheduler>:
 348:	85 df       	rcall	.-246    	; 0x254 <prvSetupTimerInterrupt>
 34a:	a0 91 71 08 	lds	r26, 0x0871	; 0x800871 <pxCurrentTCB>
 34e:	b0 91 72 08 	lds	r27, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 352:	cd 91       	ld	r28, X+
 354:	cd bf       	out	0x3d, r28	; 61
 356:	dd 91       	ld	r29, X+
 358:	de bf       	out	0x3e, r29	; 62
 35a:	ff 91       	pop	r31
 35c:	ef 91       	pop	r30
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	bf 91       	pop	r27
 364:	af 91       	pop	r26
 366:	9f 91       	pop	r25
 368:	8f 91       	pop	r24
 36a:	7f 91       	pop	r23
 36c:	6f 91       	pop	r22
 36e:	5f 91       	pop	r21
 370:	4f 91       	pop	r20
 372:	3f 91       	pop	r19
 374:	2f 91       	pop	r18
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	ff 90       	pop	r15
 37c:	ef 90       	pop	r14
 37e:	df 90       	pop	r13
 380:	cf 90       	pop	r12
 382:	bf 90       	pop	r11
 384:	af 90       	pop	r10
 386:	9f 90       	pop	r9
 388:	8f 90       	pop	r8
 38a:	7f 90       	pop	r7
 38c:	6f 90       	pop	r6
 38e:	5f 90       	pop	r5
 390:	4f 90       	pop	r4
 392:	3f 90       	pop	r3
 394:	2f 90       	pop	r2
 396:	1f 90       	pop	r1
 398:	0f 90       	pop	r0
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	0f 90       	pop	r0
 39e:	08 95       	ret
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	08 95       	ret

000003a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	f8 94       	cli
 3aa:	0f 92       	push	r0
 3ac:	1f 92       	push	r1
 3ae:	11 24       	eor	r1, r1
 3b0:	2f 92       	push	r2
 3b2:	3f 92       	push	r3
 3b4:	4f 92       	push	r4
 3b6:	5f 92       	push	r5
 3b8:	6f 92       	push	r6
 3ba:	7f 92       	push	r7
 3bc:	8f 92       	push	r8
 3be:	9f 92       	push	r9
 3c0:	af 92       	push	r10
 3c2:	bf 92       	push	r11
 3c4:	cf 92       	push	r12
 3c6:	df 92       	push	r13
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	2f 93       	push	r18
 3d2:	3f 93       	push	r19
 3d4:	4f 93       	push	r20
 3d6:	5f 93       	push	r21
 3d8:	6f 93       	push	r22
 3da:	7f 93       	push	r23
 3dc:	8f 93       	push	r24
 3de:	9f 93       	push	r25
 3e0:	af 93       	push	r26
 3e2:	bf 93       	push	r27
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	ef 93       	push	r30
 3ea:	ff 93       	push	r31
 3ec:	a0 91 71 08 	lds	r26, 0x0871	; 0x800871 <pxCurrentTCB>
 3f0:	b0 91 72 08 	lds	r27, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 3f4:	0d b6       	in	r0, 0x3d	; 61
 3f6:	0d 92       	st	X+, r0
 3f8:	0e b6       	in	r0, 0x3e	; 62
 3fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3fc:	c4 d4       	rcall	.+2440   	; 0xd86 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 3fe:	a0 91 71 08 	lds	r26, 0x0871	; 0x800871 <pxCurrentTCB>
 402:	b0 91 72 08 	lds	r27, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 406:	cd 91       	ld	r28, X+
 408:	cd bf       	out	0x3d, r28	; 61
 40a:	dd 91       	ld	r29, X+
 40c:	de bf       	out	0x3e, r29	; 62
 40e:	ff 91       	pop	r31
 410:	ef 91       	pop	r30
 412:	df 91       	pop	r29
 414:	cf 91       	pop	r28
 416:	bf 91       	pop	r27
 418:	af 91       	pop	r26
 41a:	9f 91       	pop	r25
 41c:	8f 91       	pop	r24
 41e:	7f 91       	pop	r23
 420:	6f 91       	pop	r22
 422:	5f 91       	pop	r21
 424:	4f 91       	pop	r20
 426:	3f 91       	pop	r19
 428:	2f 91       	pop	r18
 42a:	1f 91       	pop	r17
 42c:	0f 91       	pop	r16
 42e:	ff 90       	pop	r15
 430:	ef 90       	pop	r14
 432:	df 90       	pop	r13
 434:	cf 90       	pop	r12
 436:	bf 90       	pop	r11
 438:	af 90       	pop	r10
 43a:	9f 90       	pop	r9
 43c:	8f 90       	pop	r8
 43e:	7f 90       	pop	r7
 440:	6f 90       	pop	r6
 442:	5f 90       	pop	r5
 444:	4f 90       	pop	r4
 446:	3f 90       	pop	r3
 448:	2f 90       	pop	r2
 44a:	1f 90       	pop	r1
 44c:	0f 90       	pop	r0
 44e:	0f be       	out	0x3f, r0	; 63
 450:	0f 90       	pop	r0

	asm volatile ( "ret" );
 452:	08 95       	ret

00000454 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 454:	0f 92       	push	r0
 456:	0f b6       	in	r0, 0x3f	; 63
 458:	f8 94       	cli
 45a:	0f 92       	push	r0
 45c:	1f 92       	push	r1
 45e:	11 24       	eor	r1, r1
 460:	2f 92       	push	r2
 462:	3f 92       	push	r3
 464:	4f 92       	push	r4
 466:	5f 92       	push	r5
 468:	6f 92       	push	r6
 46a:	7f 92       	push	r7
 46c:	8f 92       	push	r8
 46e:	9f 92       	push	r9
 470:	af 92       	push	r10
 472:	bf 92       	push	r11
 474:	cf 92       	push	r12
 476:	df 92       	push	r13
 478:	ef 92       	push	r14
 47a:	ff 92       	push	r15
 47c:	0f 93       	push	r16
 47e:	1f 93       	push	r17
 480:	2f 93       	push	r18
 482:	3f 93       	push	r19
 484:	4f 93       	push	r20
 486:	5f 93       	push	r21
 488:	6f 93       	push	r22
 48a:	7f 93       	push	r23
 48c:	8f 93       	push	r24
 48e:	9f 93       	push	r25
 490:	af 93       	push	r26
 492:	bf 93       	push	r27
 494:	cf 93       	push	r28
 496:	df 93       	push	r29
 498:	ef 93       	push	r30
 49a:	ff 93       	push	r31
 49c:	a0 91 71 08 	lds	r26, 0x0871	; 0x800871 <pxCurrentTCB>
 4a0:	b0 91 72 08 	lds	r27, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 4a4:	0d b6       	in	r0, 0x3d	; 61
 4a6:	0d 92       	st	X+, r0
 4a8:	0e b6       	in	r0, 0x3e	; 62
 4aa:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4ac:	f7 d2       	rcall	.+1518   	; 0xa9c <xTaskIncrementTick>
 4ae:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4b0:	6a d4       	rcall	.+2260   	; 0xd86 <vTaskSwitchContext>
 4b2:	a0 91 71 08 	lds	r26, 0x0871	; 0x800871 <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
 4b6:	b0 91 72 08 	lds	r27, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 4ba:	cd 91       	ld	r28, X+
 4bc:	cd bf       	out	0x3d, r28	; 61
 4be:	dd 91       	ld	r29, X+
 4c0:	de bf       	out	0x3e, r29	; 62
 4c2:	ff 91       	pop	r31
 4c4:	ef 91       	pop	r30
 4c6:	df 91       	pop	r29
 4c8:	cf 91       	pop	r28
 4ca:	bf 91       	pop	r27
 4cc:	af 91       	pop	r26
 4ce:	9f 91       	pop	r25
 4d0:	8f 91       	pop	r24
 4d2:	7f 91       	pop	r23
 4d4:	6f 91       	pop	r22
 4d6:	5f 91       	pop	r21
 4d8:	4f 91       	pop	r20
 4da:	3f 91       	pop	r19
 4dc:	2f 91       	pop	r18
 4de:	1f 91       	pop	r17
 4e0:	0f 91       	pop	r16
 4e2:	ff 90       	pop	r15
 4e4:	ef 90       	pop	r14
 4e6:	df 90       	pop	r13
 4e8:	cf 90       	pop	r12
 4ea:	bf 90       	pop	r11
 4ec:	af 90       	pop	r10
 4ee:	9f 90       	pop	r9
 4f0:	8f 90       	pop	r8
 4f2:	7f 90       	pop	r7
 4f4:	6f 90       	pop	r6
 4f6:	5f 90       	pop	r5
 4f8:	4f 90       	pop	r4
 4fa:	3f 90       	pop	r3
 4fc:	2f 90       	pop	r2
 4fe:	1f 90       	pop	r1
 500:	0f 90       	pop	r0
 502:	0f be       	out	0x3f, r0	; 63
 504:	0f 90       	pop	r0
 506:	08 95       	ret

00000508 <__vector_17>:

	asm volatile ( "ret" );
 508:	a5 df       	rcall	.-182    	; 0x454 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 50a:	18 95       	reti

0000050c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 50c:	cf 93       	push	r28
 50e:	df 93       	push	r29
 510:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 512:	be d2       	rcall	.+1404   	; 0xa90 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 514:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <__data_end>
 518:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <__data_end+0x1>
 51c:	89 2b       	or	r24, r25
 51e:	31 f4       	brne	.+12     	; 0x52c <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 520:	89 e1       	ldi	r24, 0x19	; 25
 522:	92 e0       	ldi	r25, 0x02	; 2
 524:	90 93 15 02 	sts	0x0215, r25	; 0x800215 <__data_end+0x1>
 528:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 52c:	20 91 16 02 	lds	r18, 0x0216	; 0x800216 <xNextFreeByte>
 530:	30 91 17 02 	lds	r19, 0x0217	; 0x800217 <xNextFreeByte+0x1>
 534:	c9 01       	movw	r24, r18
 536:	8c 0f       	add	r24, r28
 538:	9d 1f       	adc	r25, r29
 53a:	8b 3d       	cpi	r24, 0xDB	; 219
 53c:	45 e0       	ldi	r20, 0x05	; 5
 53e:	94 07       	cpc	r25, r20
 540:	70 f4       	brcc	.+28     	; 0x55e <pvPortMalloc+0x52>
 542:	28 17       	cp	r18, r24
 544:	39 07       	cpc	r19, r25
 546:	70 f4       	brcc	.+28     	; 0x564 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 548:	c0 91 14 02 	lds	r28, 0x0214	; 0x800214 <__data_end>
 54c:	d0 91 15 02 	lds	r29, 0x0215	; 0x800215 <__data_end+0x1>
 550:	c2 0f       	add	r28, r18
 552:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 554:	90 93 17 02 	sts	0x0217, r25	; 0x800217 <xNextFreeByte+0x1>
 558:	80 93 16 02 	sts	0x0216, r24	; 0x800216 <xNextFreeByte>
 55c:	05 c0       	rjmp	.+10     	; 0x568 <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 55e:	c0 e0       	ldi	r28, 0x00	; 0
 560:	d0 e0       	ldi	r29, 0x00	; 0
 562:	02 c0       	rjmp	.+4      	; 0x568 <pvPortMalloc+0x5c>
 564:	c0 e0       	ldi	r28, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 566:	d0 e0       	ldi	r29, 0x00	; 0
 568:	73 d3       	rcall	.+1766   	; 0xc50 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 56a:	ce 01       	movw	r24, r28
 56c:	df 91       	pop	r29
 56e:	cf 91       	pop	r28
 570:	08 95       	ret

00000572 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 572:	08 95       	ret

00000574 <prvTaskIsTaskSuspended>:
	vTaskSuspendAll();
	xPendedTicks += xTicksToCatchUp;
	xYieldRequired = xTaskResumeAll();

	return xYieldRequired;
}
 574:	fc 01       	movw	r30, r24
 576:	24 85       	ldd	r18, Z+12	; 0x0c
 578:	35 85       	ldd	r19, Z+13	; 0x0d
 57a:	29 50       	subi	r18, 0x09	; 9
 57c:	38 40       	sbci	r19, 0x08	; 8
 57e:	59 f4       	brne	.+22     	; 0x596 <prvTaskIsTaskSuspended+0x22>
 580:	fc 01       	movw	r30, r24
 582:	80 8d       	ldd	r24, Z+24	; 0x18
 584:	91 8d       	ldd	r25, Z+25	; 0x19
 586:	f8 e0       	ldi	r31, 0x08	; 8
 588:	80 32       	cpi	r24, 0x20	; 32
 58a:	9f 07       	cpc	r25, r31
 58c:	31 f0       	breq	.+12     	; 0x59a <prvTaskIsTaskSuspended+0x26>
 58e:	89 2b       	or	r24, r25
 590:	31 f0       	breq	.+12     	; 0x59e <prvTaskIsTaskSuspended+0x2a>
 592:	80 e0       	ldi	r24, 0x00	; 0
 594:	08 95       	ret
 596:	80 e0       	ldi	r24, 0x00	; 0
 598:	08 95       	ret
 59a:	80 e0       	ldi	r24, 0x00	; 0
 59c:	08 95       	ret
 59e:	81 e0       	ldi	r24, 0x01	; 1
 5a0:	08 95       	ret

000005a2 <prvResetNextTaskUnblockTime>:
 5a2:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
 5a6:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 5aa:	80 81       	ld	r24, Z
 5ac:	81 11       	cpse	r24, r1
 5ae:	0c c0       	rjmp	.+24     	; 0x5c8 <prvResetNextTaskUnblockTime+0x26>
 5b0:	8f ef       	ldi	r24, 0xFF	; 255
 5b2:	9f ef       	ldi	r25, 0xFF	; 255
 5b4:	dc 01       	movw	r26, r24
 5b6:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <xNextTaskUnblockTime>
 5ba:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 5be:	a0 93 f9 07 	sts	0x07F9, r26	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 5c2:	b0 93 fa 07 	sts	0x07FA, r27	; 0x8007fa <xNextTaskUnblockTime+0x3>
 5c6:	08 95       	ret
 5c8:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
 5cc:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 5d0:	07 80       	ldd	r0, Z+7	; 0x07
 5d2:	f0 85       	ldd	r31, Z+8	; 0x08
 5d4:	e0 2d       	mov	r30, r0
 5d6:	00 84       	ldd	r0, Z+8	; 0x08
 5d8:	f1 85       	ldd	r31, Z+9	; 0x09
 5da:	e0 2d       	mov	r30, r0
 5dc:	82 81       	ldd	r24, Z+2	; 0x02
 5de:	93 81       	ldd	r25, Z+3	; 0x03
 5e0:	a4 81       	ldd	r26, Z+4	; 0x04
 5e2:	b5 81       	ldd	r27, Z+5	; 0x05
 5e4:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <xNextTaskUnblockTime>
 5e8:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 5ec:	a0 93 f9 07 	sts	0x07F9, r26	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 5f0:	b0 93 fa 07 	sts	0x07FA, r27	; 0x8007fa <xNextTaskUnblockTime+0x3>
 5f4:	08 95       	ret

000005f6 <prvDeleteTCB>:
 5f6:	cf 93       	push	r28
 5f8:	df 93       	push	r29
 5fa:	ec 01       	movw	r28, r24
 5fc:	8b 8d       	ldd	r24, Y+27	; 0x1b
 5fe:	9c 8d       	ldd	r25, Y+28	; 0x1c
 600:	b8 df       	rcall	.-144    	; 0x572 <vPortFree>
 602:	ce 01       	movw	r24, r28
 604:	b6 df       	rcall	.-148    	; 0x572 <vPortFree>
 606:	df 91       	pop	r29
 608:	cf 91       	pop	r28
 60a:	08 95       	ret

0000060c <prvInitialiseNewTask>:
 60c:	6f 92       	push	r6
 60e:	7f 92       	push	r7
 610:	8f 92       	push	r8
 612:	9f 92       	push	r9
 614:	af 92       	push	r10
 616:	bf 92       	push	r11
 618:	cf 92       	push	r12
 61a:	df 92       	push	r13
 61c:	ef 92       	push	r14
 61e:	0f 93       	push	r16
 620:	1f 93       	push	r17
 622:	cf 93       	push	r28
 624:	df 93       	push	r29
 626:	cd b7       	in	r28, 0x3d	; 61
 628:	de b7       	in	r29, 0x3e	; 62
 62a:	4c 01       	movw	r8, r24
 62c:	f5 01       	movw	r30, r10
 62e:	83 8d       	ldd	r24, Z+27	; 0x1b
 630:	94 8d       	ldd	r25, Z+28	; 0x1c
 632:	21 50       	subi	r18, 0x01	; 1
 634:	31 09       	sbc	r19, r1
 636:	3c 01       	movw	r6, r24
 638:	62 0e       	add	r6, r18
 63a:	73 1e       	adc	r7, r19
 63c:	61 15       	cp	r22, r1
 63e:	71 05       	cpc	r23, r1
 640:	89 f4       	brne	.+34     	; 0x664 <prvInitialiseNewTask+0x58>
 642:	16 c0       	rjmp	.+44     	; 0x670 <prvInitialiseNewTask+0x64>
 644:	82 2f       	mov	r24, r18
 646:	90 e0       	ldi	r25, 0x00	; 0
 648:	fb 01       	movw	r30, r22
 64a:	e8 0f       	add	r30, r24
 64c:	f9 1f       	adc	r31, r25
 64e:	30 81       	ld	r19, Z
 650:	d5 01       	movw	r26, r10
 652:	a8 0f       	add	r26, r24
 654:	b9 1f       	adc	r27, r25
 656:	5d 96       	adiw	r26, 0x1d	; 29
 658:	3c 93       	st	X, r19
 65a:	80 81       	ld	r24, Z
 65c:	88 23       	and	r24, r24
 65e:	29 f0       	breq	.+10     	; 0x66a <prvInitialiseNewTask+0x5e>
 660:	2f 5f       	subi	r18, 0xFF	; 255
 662:	01 c0       	rjmp	.+2      	; 0x666 <prvInitialiseNewTask+0x5a>
 664:	20 e0       	ldi	r18, 0x00	; 0
 666:	28 30       	cpi	r18, 0x08	; 8
 668:	68 f3       	brcs	.-38     	; 0x644 <prvInitialiseNewTask+0x38>
 66a:	f5 01       	movw	r30, r10
 66c:	14 a2       	std	Z+36, r1	; 0x24
 66e:	02 c0       	rjmp	.+4      	; 0x674 <prvInitialiseNewTask+0x68>
 670:	f5 01       	movw	r30, r10
 672:	15 8e       	std	Z+29, r1	; 0x1d
 674:	f3 e0       	ldi	r31, 0x03	; 3
 676:	fe 15       	cp	r31, r14
 678:	20 f4       	brcc	.+8      	; 0x682 <prvInitialiseNewTask+0x76>
 67a:	0f 2e       	mov	r0, r31
 67c:	f3 e0       	ldi	r31, 0x03	; 3
 67e:	ef 2e       	mov	r14, r31
 680:	f0 2d       	mov	r31, r0
 682:	f5 01       	movw	r30, r10
 684:	e2 8e       	std	Z+26, r14	; 0x1a
 686:	c5 01       	movw	r24, r10
 688:	02 96       	adiw	r24, 0x02	; 2
 68a:	5b dd       	rcall	.-1354   	; 0x142 <vListInitialiseItem>
 68c:	c5 01       	movw	r24, r10
 68e:	0e 96       	adiw	r24, 0x0e	; 14
 690:	58 dd       	rcall	.-1360   	; 0x142 <vListInitialiseItem>
 692:	f5 01       	movw	r30, r10
 694:	b3 86       	std	Z+11, r11	; 0x0b
 696:	a2 86       	std	Z+10, r10	; 0x0a
 698:	84 e0       	ldi	r24, 0x04	; 4
 69a:	90 e0       	ldi	r25, 0x00	; 0
 69c:	a0 e0       	ldi	r26, 0x00	; 0
 69e:	b0 e0       	ldi	r27, 0x00	; 0
 6a0:	8e 19       	sub	r24, r14
 6a2:	91 09       	sbc	r25, r1
 6a4:	a1 09       	sbc	r26, r1
 6a6:	b1 09       	sbc	r27, r1
 6a8:	86 87       	std	Z+14, r24	; 0x0e
 6aa:	97 87       	std	Z+15, r25	; 0x0f
 6ac:	a0 8b       	std	Z+16, r26	; 0x10
 6ae:	b1 8b       	std	Z+17, r27	; 0x11
 6b0:	b7 8a       	std	Z+23, r11	; 0x17
 6b2:	a6 8a       	std	Z+22, r10	; 0x16
 6b4:	15 a2       	std	Z+37, r1	; 0x25
 6b6:	16 a2       	std	Z+38, r1	; 0x26
 6b8:	17 a2       	std	Z+39, r1	; 0x27
 6ba:	10 a6       	std	Z+40, r1	; 0x28
 6bc:	11 a6       	std	Z+41, r1	; 0x29
 6be:	a8 01       	movw	r20, r16
 6c0:	b4 01       	movw	r22, r8
 6c2:	c3 01       	movw	r24, r6
 6c4:	d5 dd       	rcall	.-1110   	; 0x270 <pxPortInitialiseStack>
 6c6:	f5 01       	movw	r30, r10
 6c8:	91 83       	std	Z+1, r25	; 0x01
 6ca:	80 83       	st	Z, r24
 6cc:	c1 14       	cp	r12, r1
 6ce:	d1 04       	cpc	r13, r1
 6d0:	19 f0       	breq	.+6      	; 0x6d8 <prvInitialiseNewTask+0xcc>
 6d2:	f6 01       	movw	r30, r12
 6d4:	b1 82       	std	Z+1, r11	; 0x01
 6d6:	a0 82       	st	Z, r10
 6d8:	df 91       	pop	r29
 6da:	cf 91       	pop	r28
 6dc:	1f 91       	pop	r17
 6de:	0f 91       	pop	r16
 6e0:	ef 90       	pop	r14
 6e2:	df 90       	pop	r13
 6e4:	cf 90       	pop	r12
 6e6:	bf 90       	pop	r11
 6e8:	af 90       	pop	r10
 6ea:	9f 90       	pop	r9
 6ec:	8f 90       	pop	r8
 6ee:	7f 90       	pop	r7
 6f0:	6f 90       	pop	r6
 6f2:	08 95       	ret

000006f4 <prvInitialiseTaskLists>:
 6f4:	cf 93       	push	r28
 6f6:	c0 e0       	ldi	r28, 0x00	; 0
 6f8:	08 c0       	rjmp	.+16     	; 0x70a <prvInitialiseTaskLists+0x16>
 6fa:	2b e0       	ldi	r18, 0x0B	; 11
 6fc:	c2 9f       	mul	r28, r18
 6fe:	c0 01       	movw	r24, r0
 700:	11 24       	eor	r1, r1
 702:	8b 5b       	subi	r24, 0xBB	; 187
 704:	97 4f       	sbci	r25, 0xF7	; 247
 706:	0c dd       	rcall	.-1512   	; 0x120 <vListInitialise>
 708:	cf 5f       	subi	r28, 0xFF	; 255
 70a:	c4 30       	cpi	r28, 0x04	; 4
 70c:	b0 f3       	brcs	.-20     	; 0x6fa <prvInitialiseTaskLists+0x6>
 70e:	8a e3       	ldi	r24, 0x3A	; 58
 710:	98 e0       	ldi	r25, 0x08	; 8
 712:	06 dd       	rcall	.-1524   	; 0x120 <vListInitialise>
 714:	8f e2       	ldi	r24, 0x2F	; 47
 716:	98 e0       	ldi	r25, 0x08	; 8
 718:	03 dd       	rcall	.-1530   	; 0x120 <vListInitialise>
 71a:	80 e2       	ldi	r24, 0x20	; 32
 71c:	98 e0       	ldi	r25, 0x08	; 8
 71e:	00 dd       	rcall	.-1536   	; 0x120 <vListInitialise>
 720:	85 e1       	ldi	r24, 0x15	; 21
 722:	98 e0       	ldi	r25, 0x08	; 8
 724:	fd dc       	rcall	.-1542   	; 0x120 <vListInitialise>
 726:	89 e0       	ldi	r24, 0x09	; 9
 728:	98 e0       	ldi	r25, 0x08	; 8
 72a:	fa dc       	rcall	.-1548   	; 0x120 <vListInitialise>
 72c:	8a e3       	ldi	r24, 0x3A	; 58
 72e:	98 e0       	ldi	r25, 0x08	; 8
 730:	90 93 2e 08 	sts	0x082E, r25	; 0x80082e <pxDelayedTaskList+0x1>
 734:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <pxDelayedTaskList>
 738:	8f e2       	ldi	r24, 0x2F	; 47
 73a:	98 e0       	ldi	r25, 0x08	; 8
 73c:	90 93 2c 08 	sts	0x082C, r25	; 0x80082c <pxOverflowDelayedTaskList+0x1>
 740:	80 93 2b 08 	sts	0x082B, r24	; 0x80082b <pxOverflowDelayedTaskList>
 744:	cf 91       	pop	r28
 746:	08 95       	ret

00000748 <prvAddNewTaskToReadyList>:
 748:	cf 93       	push	r28
 74a:	df 93       	push	r29
 74c:	ec 01       	movw	r28, r24
 74e:	0f b6       	in	r0, 0x3f	; 63
 750:	f8 94       	cli
 752:	0f 92       	push	r0
 754:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxCurrentNumberOfTasks>
 758:	8f 5f       	subi	r24, 0xFF	; 255
 75a:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxCurrentNumberOfTasks>
 75e:	80 91 71 08 	lds	r24, 0x0871	; 0x800871 <pxCurrentTCB>
 762:	90 91 72 08 	lds	r25, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 766:	89 2b       	or	r24, r25
 768:	51 f4       	brne	.+20     	; 0x77e <prvAddNewTaskToReadyList+0x36>
 76a:	d0 93 72 08 	sts	0x0872, r29	; 0x800872 <pxCurrentTCB+0x1>
 76e:	c0 93 71 08 	sts	0x0871, r28	; 0x800871 <pxCurrentTCB>
 772:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxCurrentNumberOfTasks>
 776:	81 30       	cpi	r24, 0x01	; 1
 778:	91 f4       	brne	.+36     	; 0x79e <prvAddNewTaskToReadyList+0x56>
 77a:	bc df       	rcall	.-136    	; 0x6f4 <prvInitialiseTaskLists>
 77c:	10 c0       	rjmp	.+32     	; 0x79e <prvAddNewTaskToReadyList+0x56>
 77e:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xSchedulerRunning>
 782:	81 11       	cpse	r24, r1
 784:	0c c0       	rjmp	.+24     	; 0x79e <prvAddNewTaskToReadyList+0x56>
 786:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 78a:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 78e:	92 8d       	ldd	r25, Z+26	; 0x1a
 790:	8a 8d       	ldd	r24, Y+26	; 0x1a
 792:	89 17       	cp	r24, r25
 794:	20 f0       	brcs	.+8      	; 0x79e <prvAddNewTaskToReadyList+0x56>
 796:	d0 93 72 08 	sts	0x0872, r29	; 0x800872 <pxCurrentTCB+0x1>
 79a:	c0 93 71 08 	sts	0x0871, r28	; 0x800871 <pxCurrentTCB>
 79e:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <uxTaskNumber>
 7a2:	8f 5f       	subi	r24, 0xFF	; 255
 7a4:	80 93 fb 07 	sts	0x07FB, r24	; 0x8007fb <uxTaskNumber>
 7a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7aa:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <uxTopReadyPriority>
 7ae:	98 17       	cp	r25, r24
 7b0:	10 f4       	brcc	.+4      	; 0x7b6 <prvAddNewTaskToReadyList+0x6e>
 7b2:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <uxTopReadyPriority>
 7b6:	2b e0       	ldi	r18, 0x0B	; 11
 7b8:	82 9f       	mul	r24, r18
 7ba:	c0 01       	movw	r24, r0
 7bc:	11 24       	eor	r1, r1
 7be:	be 01       	movw	r22, r28
 7c0:	6e 5f       	subi	r22, 0xFE	; 254
 7c2:	7f 4f       	sbci	r23, 0xFF	; 255
 7c4:	8b 5b       	subi	r24, 0xBB	; 187
 7c6:	97 4f       	sbci	r25, 0xF7	; 247
 7c8:	c0 dc       	rcall	.-1664   	; 0x14a <vListInsertEnd>
 7ca:	0f 90       	pop	r0
 7cc:	0f be       	out	0x3f, r0	; 63
 7ce:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xSchedulerRunning>
 7d2:	88 23       	and	r24, r24
 7d4:	49 f0       	breq	.+18     	; 0x7e8 <prvAddNewTaskToReadyList+0xa0>
 7d6:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 7da:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 7de:	92 8d       	ldd	r25, Z+26	; 0x1a
 7e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 7e2:	98 17       	cp	r25, r24
 7e4:	08 f4       	brcc	.+2      	; 0x7e8 <prvAddNewTaskToReadyList+0xa0>
 7e6:	de dd       	rcall	.-1092   	; 0x3a4 <vPortYield>
 7e8:	df 91       	pop	r29
 7ea:	cf 91       	pop	r28
 7ec:	08 95       	ret

000007ee <prvCheckTasksWaitingTermination>:
 7ee:	cf 93       	push	r28
 7f0:	df 93       	push	r29
 7f2:	1a c0       	rjmp	.+52     	; 0x828 <prvCheckTasksWaitingTermination+0x3a>
 7f4:	0f b6       	in	r0, 0x3f	; 63
 7f6:	f8 94       	cli
 7f8:	0f 92       	push	r0
 7fa:	e0 91 1c 08 	lds	r30, 0x081C	; 0x80081c <xTasksWaitingTermination+0x7>
 7fe:	f0 91 1d 08 	lds	r31, 0x081D	; 0x80081d <xTasksWaitingTermination+0x8>
 802:	c0 85       	ldd	r28, Z+8	; 0x08
 804:	d1 85       	ldd	r29, Z+9	; 0x09
 806:	ce 01       	movw	r24, r28
 808:	02 96       	adiw	r24, 0x02	; 2
 80a:	fd dc       	rcall	.-1542   	; 0x206 <uxListRemove>
 80c:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxCurrentNumberOfTasks>
 810:	81 50       	subi	r24, 0x01	; 1
 812:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxCurrentNumberOfTasks>
 816:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <uxDeletedTasksWaitingCleanUp>
 81a:	81 50       	subi	r24, 0x01	; 1
 81c:	80 93 14 08 	sts	0x0814, r24	; 0x800814 <uxDeletedTasksWaitingCleanUp>
 820:	0f 90       	pop	r0
 822:	0f be       	out	0x3f, r0	; 63
 824:	ce 01       	movw	r24, r28
 826:	e7 de       	rcall	.-562    	; 0x5f6 <prvDeleteTCB>
 828:	80 91 14 08 	lds	r24, 0x0814	; 0x800814 <uxDeletedTasksWaitingCleanUp>
 82c:	81 11       	cpse	r24, r1
 82e:	e2 cf       	rjmp	.-60     	; 0x7f4 <prvCheckTasksWaitingTermination+0x6>
 830:	df 91       	pop	r29
 832:	cf 91       	pop	r28
 834:	08 95       	ret

00000836 <prvIdleTask>:
 836:	db df       	rcall	.-74     	; 0x7ee <prvCheckTasksWaitingTermination>
 838:	fe cf       	rjmp	.-4      	; 0x836 <prvIdleTask>

0000083a <prvAddCurrentTaskToDelayedList>:
 83a:	8f 92       	push	r8
 83c:	9f 92       	push	r9
 83e:	af 92       	push	r10
 840:	bf 92       	push	r11
 842:	cf 92       	push	r12
 844:	df 92       	push	r13
 846:	ef 92       	push	r14
 848:	ff 92       	push	r15
 84a:	cf 93       	push	r28
 84c:	6b 01       	movw	r12, r22
 84e:	7c 01       	movw	r14, r24
 850:	c4 2f       	mov	r28, r20
 852:	80 90 04 08 	lds	r8, 0x0804	; 0x800804 <xTickCount>
 856:	90 90 05 08 	lds	r9, 0x0805	; 0x800805 <xTickCount+0x1>
 85a:	a0 90 06 08 	lds	r10, 0x0806	; 0x800806 <xTickCount+0x2>
 85e:	b0 90 07 08 	lds	r11, 0x0807	; 0x800807 <xTickCount+0x3>
 862:	80 91 71 08 	lds	r24, 0x0871	; 0x800871 <pxCurrentTCB>
 866:	90 91 72 08 	lds	r25, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 86a:	02 96       	adiw	r24, 0x02	; 2
 86c:	cc dc       	rcall	.-1640   	; 0x206 <uxListRemove>
 86e:	8f ef       	ldi	r24, 0xFF	; 255
 870:	c8 16       	cp	r12, r24
 872:	d8 06       	cpc	r13, r24
 874:	e8 06       	cpc	r14, r24
 876:	f8 06       	cpc	r15, r24
 878:	61 f4       	brne	.+24     	; 0x892 <prvAddCurrentTaskToDelayedList+0x58>
 87a:	cc 23       	and	r28, r28
 87c:	51 f0       	breq	.+20     	; 0x892 <prvAddCurrentTaskToDelayedList+0x58>
 87e:	60 91 71 08 	lds	r22, 0x0871	; 0x800871 <pxCurrentTCB>
 882:	70 91 72 08 	lds	r23, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 886:	6e 5f       	subi	r22, 0xFE	; 254
 888:	7f 4f       	sbci	r23, 0xFF	; 255
 88a:	89 e0       	ldi	r24, 0x09	; 9
 88c:	98 e0       	ldi	r25, 0x08	; 8
 88e:	5d dc       	rcall	.-1862   	; 0x14a <vListInsertEnd>
 890:	3d c0       	rjmp	.+122    	; 0x90c <prvAddCurrentTaskToDelayedList+0xd2>
 892:	c8 0c       	add	r12, r8
 894:	d9 1c       	adc	r13, r9
 896:	ea 1c       	adc	r14, r10
 898:	fb 1c       	adc	r15, r11
 89a:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 89e:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 8a2:	c2 82       	std	Z+2, r12	; 0x02
 8a4:	d3 82       	std	Z+3, r13	; 0x03
 8a6:	e4 82       	std	Z+4, r14	; 0x04
 8a8:	f5 82       	std	Z+5, r15	; 0x05
 8aa:	c8 14       	cp	r12, r8
 8ac:	d9 04       	cpc	r13, r9
 8ae:	ea 04       	cpc	r14, r10
 8b0:	fb 04       	cpc	r15, r11
 8b2:	60 f4       	brcc	.+24     	; 0x8cc <prvAddCurrentTaskToDelayedList+0x92>
 8b4:	60 91 71 08 	lds	r22, 0x0871	; 0x800871 <pxCurrentTCB>
 8b8:	70 91 72 08 	lds	r23, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 8bc:	80 91 2b 08 	lds	r24, 0x082B	; 0x80082b <pxOverflowDelayedTaskList>
 8c0:	90 91 2c 08 	lds	r25, 0x082C	; 0x80082c <pxOverflowDelayedTaskList+0x1>
 8c4:	6e 5f       	subi	r22, 0xFE	; 254
 8c6:	7f 4f       	sbci	r23, 0xFF	; 255
 8c8:	61 dc       	rcall	.-1854   	; 0x18c <vListInsert>
 8ca:	20 c0       	rjmp	.+64     	; 0x90c <prvAddCurrentTaskToDelayedList+0xd2>
 8cc:	60 91 71 08 	lds	r22, 0x0871	; 0x800871 <pxCurrentTCB>
 8d0:	70 91 72 08 	lds	r23, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 8d4:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <pxDelayedTaskList>
 8d8:	90 91 2e 08 	lds	r25, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 8dc:	6e 5f       	subi	r22, 0xFE	; 254
 8de:	7f 4f       	sbci	r23, 0xFF	; 255
 8e0:	55 dc       	rcall	.-1878   	; 0x18c <vListInsert>
 8e2:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <xNextTaskUnblockTime>
 8e6:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 8ea:	a0 91 f9 07 	lds	r26, 0x07F9	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 8ee:	b0 91 fa 07 	lds	r27, 0x07FA	; 0x8007fa <xNextTaskUnblockTime+0x3>
 8f2:	c8 16       	cp	r12, r24
 8f4:	d9 06       	cpc	r13, r25
 8f6:	ea 06       	cpc	r14, r26
 8f8:	fb 06       	cpc	r15, r27
 8fa:	40 f4       	brcc	.+16     	; 0x90c <prvAddCurrentTaskToDelayedList+0xd2>
 8fc:	c0 92 f7 07 	sts	0x07F7, r12	; 0x8007f7 <xNextTaskUnblockTime>
 900:	d0 92 f8 07 	sts	0x07F8, r13	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 904:	e0 92 f9 07 	sts	0x07F9, r14	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 908:	f0 92 fa 07 	sts	0x07FA, r15	; 0x8007fa <xNextTaskUnblockTime+0x3>
 90c:	cf 91       	pop	r28
 90e:	ff 90       	pop	r15
 910:	ef 90       	pop	r14
 912:	df 90       	pop	r13
 914:	cf 90       	pop	r12
 916:	bf 90       	pop	r11
 918:	af 90       	pop	r10
 91a:	9f 90       	pop	r9
 91c:	8f 90       	pop	r8
 91e:	08 95       	ret

00000920 <xTaskCreate>:
 920:	2f 92       	push	r2
 922:	3f 92       	push	r3
 924:	4f 92       	push	r4
 926:	5f 92       	push	r5
 928:	6f 92       	push	r6
 92a:	7f 92       	push	r7
 92c:	8f 92       	push	r8
 92e:	9f 92       	push	r9
 930:	af 92       	push	r10
 932:	bf 92       	push	r11
 934:	cf 92       	push	r12
 936:	df 92       	push	r13
 938:	ef 92       	push	r14
 93a:	ff 92       	push	r15
 93c:	0f 93       	push	r16
 93e:	1f 93       	push	r17
 940:	cf 93       	push	r28
 942:	df 93       	push	r29
 944:	3c 01       	movw	r6, r24
 946:	1b 01       	movw	r2, r22
 948:	5a 01       	movw	r10, r20
 94a:	29 01       	movw	r4, r18
 94c:	ca 01       	movw	r24, r20
 94e:	de dd       	rcall	.-1092   	; 0x50c <pvPortMalloc>
 950:	6c 01       	movw	r12, r24
 952:	89 2b       	or	r24, r25
 954:	61 f0       	breq	.+24     	; 0x96e <xTaskCreate+0x4e>
 956:	8a e2       	ldi	r24, 0x2A	; 42
 958:	90 e0       	ldi	r25, 0x00	; 0
 95a:	d8 dd       	rcall	.-1104   	; 0x50c <pvPortMalloc>
 95c:	ec 01       	movw	r28, r24
 95e:	89 2b       	or	r24, r25
 960:	19 f0       	breq	.+6      	; 0x968 <xTaskCreate+0x48>
 962:	dc 8e       	std	Y+28, r13	; 0x1c
 964:	cb 8e       	std	Y+27, r12	; 0x1b
 966:	05 c0       	rjmp	.+10     	; 0x972 <xTaskCreate+0x52>
 968:	c6 01       	movw	r24, r12
 96a:	03 de       	rcall	.-1018   	; 0x572 <vPortFree>
 96c:	02 c0       	rjmp	.+4      	; 0x972 <xTaskCreate+0x52>
 96e:	c0 e0       	ldi	r28, 0x00	; 0
 970:	d0 e0       	ldi	r29, 0x00	; 0
 972:	20 97       	sbiw	r28, 0x00	; 0
 974:	81 f0       	breq	.+32     	; 0x996 <xTaskCreate+0x76>
 976:	95 01       	movw	r18, r10
 978:	40 e0       	ldi	r20, 0x00	; 0
 97a:	50 e0       	ldi	r21, 0x00	; 0
 97c:	81 2c       	mov	r8, r1
 97e:	91 2c       	mov	r9, r1
 980:	5e 01       	movw	r10, r28
 982:	67 01       	movw	r12, r14
 984:	e0 2e       	mov	r14, r16
 986:	82 01       	movw	r16, r4
 988:	b1 01       	movw	r22, r2
 98a:	c3 01       	movw	r24, r6
 98c:	3f de       	rcall	.-898    	; 0x60c <prvInitialiseNewTask>
 98e:	ce 01       	movw	r24, r28
 990:	db de       	rcall	.-586    	; 0x748 <prvAddNewTaskToReadyList>
 992:	81 e0       	ldi	r24, 0x01	; 1
 994:	01 c0       	rjmp	.+2      	; 0x998 <xTaskCreate+0x78>
 996:	8f ef       	ldi	r24, 0xFF	; 255
 998:	df 91       	pop	r29
 99a:	cf 91       	pop	r28
 99c:	1f 91       	pop	r17
 99e:	0f 91       	pop	r16
 9a0:	ff 90       	pop	r15
 9a2:	ef 90       	pop	r14
 9a4:	df 90       	pop	r13
 9a6:	cf 90       	pop	r12
 9a8:	bf 90       	pop	r11
 9aa:	af 90       	pop	r10
 9ac:	9f 90       	pop	r9
 9ae:	8f 90       	pop	r8
 9b0:	7f 90       	pop	r7
 9b2:	6f 90       	pop	r6
 9b4:	5f 90       	pop	r5
 9b6:	4f 90       	pop	r4
 9b8:	3f 90       	pop	r3
 9ba:	2f 90       	pop	r2
 9bc:	08 95       	ret

000009be <vTaskResume>:
 9be:	0f 93       	push	r16
 9c0:	1f 93       	push	r17
 9c2:	cf 93       	push	r28
 9c4:	df 93       	push	r29
 9c6:	20 91 71 08 	lds	r18, 0x0871	; 0x800871 <pxCurrentTCB>
 9ca:	30 91 72 08 	lds	r19, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 9ce:	82 17       	cp	r24, r18
 9d0:	93 07       	cpc	r25, r19
 9d2:	41 f1       	breq	.+80     	; 0xa24 <vTaskResume+0x66>
 9d4:	00 97       	sbiw	r24, 0x00	; 0
 9d6:	31 f1       	breq	.+76     	; 0xa24 <vTaskResume+0x66>
 9d8:	ec 01       	movw	r28, r24
 9da:	0f b6       	in	r0, 0x3f	; 63
 9dc:	f8 94       	cli
 9de:	0f 92       	push	r0
 9e0:	c9 dd       	rcall	.-1134   	; 0x574 <prvTaskIsTaskSuspended>
 9e2:	88 23       	and	r24, r24
 9e4:	e9 f0       	breq	.+58     	; 0xa20 <vTaskResume+0x62>
 9e6:	8e 01       	movw	r16, r28
 9e8:	0e 5f       	subi	r16, 0xFE	; 254
 9ea:	1f 4f       	sbci	r17, 0xFF	; 255
 9ec:	c8 01       	movw	r24, r16
 9ee:	0b dc       	rcall	.-2026   	; 0x206 <uxListRemove>
 9f0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 9f2:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <uxTopReadyPriority>
 9f6:	98 17       	cp	r25, r24
 9f8:	10 f4       	brcc	.+4      	; 0x9fe <vTaskResume+0x40>
 9fa:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <uxTopReadyPriority>
 9fe:	2b e0       	ldi	r18, 0x0B	; 11
 a00:	82 9f       	mul	r24, r18
 a02:	c0 01       	movw	r24, r0
 a04:	11 24       	eor	r1, r1
 a06:	b8 01       	movw	r22, r16
 a08:	8b 5b       	subi	r24, 0xBB	; 187
 a0a:	97 4f       	sbci	r25, 0xF7	; 247
 a0c:	9e db       	rcall	.-2244   	; 0x14a <vListInsertEnd>
 a0e:	9a 8d       	ldd	r25, Y+26	; 0x1a
 a10:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 a14:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 a18:	82 8d       	ldd	r24, Z+26	; 0x1a
 a1a:	98 17       	cp	r25, r24
 a1c:	08 f0       	brcs	.+2      	; 0xa20 <vTaskResume+0x62>
 a1e:	c2 dc       	rcall	.-1660   	; 0x3a4 <vPortYield>
 a20:	0f 90       	pop	r0
 a22:	0f be       	out	0x3f, r0	; 63
 a24:	df 91       	pop	r29
 a26:	cf 91       	pop	r28
 a28:	1f 91       	pop	r17
 a2a:	0f 91       	pop	r16
 a2c:	08 95       	ret

00000a2e <vTaskStartScheduler>:
 a2e:	ef 92       	push	r14
 a30:	ff 92       	push	r15
 a32:	0f 93       	push	r16
 a34:	0f 2e       	mov	r0, r31
 a36:	f5 ef       	ldi	r31, 0xF5	; 245
 a38:	ef 2e       	mov	r14, r31
 a3a:	f7 e0       	ldi	r31, 0x07	; 7
 a3c:	ff 2e       	mov	r15, r31
 a3e:	f0 2d       	mov	r31, r0
 a40:	00 e0       	ldi	r16, 0x00	; 0
 a42:	20 e0       	ldi	r18, 0x00	; 0
 a44:	30 e0       	ldi	r19, 0x00	; 0
 a46:	45 e5       	ldi	r20, 0x55	; 85
 a48:	50 e0       	ldi	r21, 0x00	; 0
 a4a:	60 e0       	ldi	r22, 0x00	; 0
 a4c:	72 e0       	ldi	r23, 0x02	; 2
 a4e:	8b e1       	ldi	r24, 0x1B	; 27
 a50:	94 e0       	ldi	r25, 0x04	; 4
 a52:	66 df       	rcall	.-308    	; 0x920 <xTaskCreate>
 a54:	81 30       	cpi	r24, 0x01	; 1
 a56:	c1 f4       	brne	.+48     	; 0xa88 <vTaskStartScheduler+0x5a>
 a58:	f8 94       	cli
 a5a:	8f ef       	ldi	r24, 0xFF	; 255
 a5c:	9f ef       	ldi	r25, 0xFF	; 255
 a5e:	dc 01       	movw	r26, r24
 a60:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <xNextTaskUnblockTime>
 a64:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 a68:	a0 93 f9 07 	sts	0x07F9, r26	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 a6c:	b0 93 fa 07 	sts	0x07FA, r27	; 0x8007fa <xNextTaskUnblockTime+0x3>
 a70:	81 e0       	ldi	r24, 0x01	; 1
 a72:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <xSchedulerRunning>
 a76:	10 92 04 08 	sts	0x0804, r1	; 0x800804 <xTickCount>
 a7a:	10 92 05 08 	sts	0x0805, r1	; 0x800805 <xTickCount+0x1>
 a7e:	10 92 06 08 	sts	0x0806, r1	; 0x800806 <xTickCount+0x2>
 a82:	10 92 07 08 	sts	0x0807, r1	; 0x800807 <xTickCount+0x3>
 a86:	60 dc       	rcall	.-1856   	; 0x348 <xPortStartScheduler>
 a88:	0f 91       	pop	r16
 a8a:	ff 90       	pop	r15
 a8c:	ef 90       	pop	r14
 a8e:	08 95       	ret

00000a90 <vTaskSuspendAll>:
 a90:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 a94:	8f 5f       	subi	r24, 0xFF	; 255
 a96:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <uxSchedulerSuspended>
 a9a:	08 95       	ret

00000a9c <xTaskIncrementTick>:
 a9c:	bf 92       	push	r11
 a9e:	cf 92       	push	r12
 aa0:	df 92       	push	r13
 aa2:	ef 92       	push	r14
 aa4:	ff 92       	push	r15
 aa6:	0f 93       	push	r16
 aa8:	1f 93       	push	r17
 aaa:	cf 93       	push	r28
 aac:	df 93       	push	r29
 aae:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 ab2:	81 11       	cpse	r24, r1
 ab4:	ab c0       	rjmp	.+342    	; 0xc0c <xTaskIncrementTick+0x170>
 ab6:	c0 90 04 08 	lds	r12, 0x0804	; 0x800804 <xTickCount>
 aba:	d0 90 05 08 	lds	r13, 0x0805	; 0x800805 <xTickCount+0x1>
 abe:	e0 90 06 08 	lds	r14, 0x0806	; 0x800806 <xTickCount+0x2>
 ac2:	f0 90 07 08 	lds	r15, 0x0807	; 0x800807 <xTickCount+0x3>
 ac6:	2f ef       	ldi	r18, 0xFF	; 255
 ac8:	c2 1a       	sub	r12, r18
 aca:	d2 0a       	sbc	r13, r18
 acc:	e2 0a       	sbc	r14, r18
 ace:	f2 0a       	sbc	r15, r18
 ad0:	c0 92 04 08 	sts	0x0804, r12	; 0x800804 <xTickCount>
 ad4:	d0 92 05 08 	sts	0x0805, r13	; 0x800805 <xTickCount+0x1>
 ad8:	e0 92 06 08 	sts	0x0806, r14	; 0x800806 <xTickCount+0x2>
 adc:	f0 92 07 08 	sts	0x0807, r15	; 0x800807 <xTickCount+0x3>
 ae0:	c1 14       	cp	r12, r1
 ae2:	d1 04       	cpc	r13, r1
 ae4:	e1 04       	cpc	r14, r1
 ae6:	f1 04       	cpc	r15, r1
 ae8:	b1 f4       	brne	.+44     	; 0xb16 <xTaskIncrementTick+0x7a>
 aea:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <pxDelayedTaskList>
 aee:	90 91 2e 08 	lds	r25, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 af2:	20 91 2b 08 	lds	r18, 0x082B	; 0x80082b <pxOverflowDelayedTaskList>
 af6:	30 91 2c 08 	lds	r19, 0x082C	; 0x80082c <pxOverflowDelayedTaskList+0x1>
 afa:	30 93 2e 08 	sts	0x082E, r19	; 0x80082e <pxDelayedTaskList+0x1>
 afe:	20 93 2d 08 	sts	0x082D, r18	; 0x80082d <pxDelayedTaskList>
 b02:	90 93 2c 08 	sts	0x082C, r25	; 0x80082c <pxOverflowDelayedTaskList+0x1>
 b06:	80 93 2b 08 	sts	0x082B, r24	; 0x80082b <pxOverflowDelayedTaskList>
 b0a:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <xNumOfOverflows>
 b0e:	8f 5f       	subi	r24, 0xFF	; 255
 b10:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <xNumOfOverflows>
 b14:	46 dd       	rcall	.-1396   	; 0x5a2 <prvResetNextTaskUnblockTime>
 b16:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <xNextTaskUnblockTime>
 b1a:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 b1e:	a0 91 f9 07 	lds	r26, 0x07F9	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 b22:	b0 91 fa 07 	lds	r27, 0x07FA	; 0x8007fa <xNextTaskUnblockTime+0x3>
 b26:	c8 16       	cp	r12, r24
 b28:	d9 06       	cpc	r13, r25
 b2a:	ea 06       	cpc	r14, r26
 b2c:	fb 06       	cpc	r15, r27
 b2e:	28 f4       	brcc	.+10     	; 0xb3a <xTaskIncrementTick+0x9e>
 b30:	b1 2c       	mov	r11, r1
 b32:	57 c0       	rjmp	.+174    	; 0xbe2 <xTaskIncrementTick+0x146>
 b34:	bb 24       	eor	r11, r11
 b36:	b3 94       	inc	r11
 b38:	01 c0       	rjmp	.+2      	; 0xb3c <xTaskIncrementTick+0xa0>
 b3a:	b1 2c       	mov	r11, r1
 b3c:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
 b40:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 b44:	80 81       	ld	r24, Z
 b46:	81 11       	cpse	r24, r1
 b48:	0c c0       	rjmp	.+24     	; 0xb62 <xTaskIncrementTick+0xc6>
 b4a:	8f ef       	ldi	r24, 0xFF	; 255
 b4c:	9f ef       	ldi	r25, 0xFF	; 255
 b4e:	dc 01       	movw	r26, r24
 b50:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <xNextTaskUnblockTime>
 b54:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 b58:	a0 93 f9 07 	sts	0x07F9, r26	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 b5c:	b0 93 fa 07 	sts	0x07FA, r27	; 0x8007fa <xNextTaskUnblockTime+0x3>
 b60:	40 c0       	rjmp	.+128    	; 0xbe2 <xTaskIncrementTick+0x146>
 b62:	e0 91 2d 08 	lds	r30, 0x082D	; 0x80082d <pxDelayedTaskList>
 b66:	f0 91 2e 08 	lds	r31, 0x082E	; 0x80082e <pxDelayedTaskList+0x1>
 b6a:	07 80       	ldd	r0, Z+7	; 0x07
 b6c:	f0 85       	ldd	r31, Z+8	; 0x08
 b6e:	e0 2d       	mov	r30, r0
 b70:	c0 85       	ldd	r28, Z+8	; 0x08
 b72:	d1 85       	ldd	r29, Z+9	; 0x09
 b74:	8a 81       	ldd	r24, Y+2	; 0x02
 b76:	9b 81       	ldd	r25, Y+3	; 0x03
 b78:	ac 81       	ldd	r26, Y+4	; 0x04
 b7a:	bd 81       	ldd	r27, Y+5	; 0x05
 b7c:	c8 16       	cp	r12, r24
 b7e:	d9 06       	cpc	r13, r25
 b80:	ea 06       	cpc	r14, r26
 b82:	fb 06       	cpc	r15, r27
 b84:	48 f4       	brcc	.+18     	; 0xb98 <xTaskIncrementTick+0xfc>
 b86:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <xNextTaskUnblockTime>
 b8a:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <xNextTaskUnblockTime+0x1>
 b8e:	a0 93 f9 07 	sts	0x07F9, r26	; 0x8007f9 <xNextTaskUnblockTime+0x2>
 b92:	b0 93 fa 07 	sts	0x07FA, r27	; 0x8007fa <xNextTaskUnblockTime+0x3>
 b96:	25 c0       	rjmp	.+74     	; 0xbe2 <xTaskIncrementTick+0x146>
 b98:	8e 01       	movw	r16, r28
 b9a:	0e 5f       	subi	r16, 0xFE	; 254
 b9c:	1f 4f       	sbci	r17, 0xFF	; 255
 b9e:	c8 01       	movw	r24, r16
 ba0:	32 db       	rcall	.-2460   	; 0x206 <uxListRemove>
 ba2:	88 8d       	ldd	r24, Y+24	; 0x18
 ba4:	99 8d       	ldd	r25, Y+25	; 0x19
 ba6:	89 2b       	or	r24, r25
 ba8:	19 f0       	breq	.+6      	; 0xbb0 <xTaskIncrementTick+0x114>
 baa:	ce 01       	movw	r24, r28
 bac:	0e 96       	adiw	r24, 0x0e	; 14
 bae:	2b db       	rcall	.-2474   	; 0x206 <uxListRemove>
 bb0:	8a 8d       	ldd	r24, Y+26	; 0x1a
 bb2:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <uxTopReadyPriority>
 bb6:	98 17       	cp	r25, r24
 bb8:	10 f4       	brcc	.+4      	; 0xbbe <xTaskIncrementTick+0x122>
 bba:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <uxTopReadyPriority>
 bbe:	2b e0       	ldi	r18, 0x0B	; 11
 bc0:	82 9f       	mul	r24, r18
 bc2:	c0 01       	movw	r24, r0
 bc4:	11 24       	eor	r1, r1
 bc6:	b8 01       	movw	r22, r16
 bc8:	8b 5b       	subi	r24, 0xBB	; 187
 bca:	97 4f       	sbci	r25, 0xF7	; 247
 bcc:	be da       	rcall	.-2692   	; 0x14a <vListInsertEnd>
 bce:	9a 8d       	ldd	r25, Y+26	; 0x1a
 bd0:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 bd4:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 bd8:	82 8d       	ldd	r24, Z+26	; 0x1a
 bda:	98 17       	cp	r25, r24
 bdc:	08 f0       	brcs	.+2      	; 0xbe0 <xTaskIncrementTick+0x144>
 bde:	aa cf       	rjmp	.-172    	; 0xb34 <xTaskIncrementTick+0x98>
 be0:	ad cf       	rjmp	.-166    	; 0xb3c <xTaskIncrementTick+0xa0>
 be2:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 be6:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 bea:	e2 8d       	ldd	r30, Z+26	; 0x1a
 bec:	8b e0       	ldi	r24, 0x0B	; 11
 bee:	e8 9f       	mul	r30, r24
 bf0:	f0 01       	movw	r30, r0
 bf2:	11 24       	eor	r1, r1
 bf4:	eb 5b       	subi	r30, 0xBB	; 187
 bf6:	f7 4f       	sbci	r31, 0xF7	; 247
 bf8:	80 81       	ld	r24, Z
 bfa:	82 30       	cpi	r24, 0x02	; 2
 bfc:	10 f0       	brcs	.+4      	; 0xc02 <xTaskIncrementTick+0x166>
 bfe:	bb 24       	eor	r11, r11
 c00:	b3 94       	inc	r11
 c02:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <xYieldPending>
 c06:	81 11       	cpse	r24, r1
 c08:	16 c0       	rjmp	.+44     	; 0xc36 <xTaskIncrementTick+0x19a>
 c0a:	17 c0       	rjmp	.+46     	; 0xc3a <xTaskIncrementTick+0x19e>
 c0c:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <xPendedTicks>
 c10:	90 91 ff 07 	lds	r25, 0x07FF	; 0x8007ff <xPendedTicks+0x1>
 c14:	a0 91 00 08 	lds	r26, 0x0800	; 0x800800 <xPendedTicks+0x2>
 c18:	b0 91 01 08 	lds	r27, 0x0801	; 0x800801 <xPendedTicks+0x3>
 c1c:	01 96       	adiw	r24, 0x01	; 1
 c1e:	a1 1d       	adc	r26, r1
 c20:	b1 1d       	adc	r27, r1
 c22:	80 93 fe 07 	sts	0x07FE, r24	; 0x8007fe <xPendedTicks>
 c26:	90 93 ff 07 	sts	0x07FF, r25	; 0x8007ff <xPendedTicks+0x1>
 c2a:	a0 93 00 08 	sts	0x0800, r26	; 0x800800 <xPendedTicks+0x2>
 c2e:	b0 93 01 08 	sts	0x0801, r27	; 0x800801 <xPendedTicks+0x3>
 c32:	b1 2c       	mov	r11, r1
 c34:	02 c0       	rjmp	.+4      	; 0xc3a <xTaskIncrementTick+0x19e>
 c36:	bb 24       	eor	r11, r11
 c38:	b3 94       	inc	r11
 c3a:	8b 2d       	mov	r24, r11
 c3c:	df 91       	pop	r29
 c3e:	cf 91       	pop	r28
 c40:	1f 91       	pop	r17
 c42:	0f 91       	pop	r16
 c44:	ff 90       	pop	r15
 c46:	ef 90       	pop	r14
 c48:	df 90       	pop	r13
 c4a:	cf 90       	pop	r12
 c4c:	bf 90       	pop	r11
 c4e:	08 95       	ret

00000c50 <xTaskResumeAll>:
 c50:	cf 92       	push	r12
 c52:	df 92       	push	r13
 c54:	ef 92       	push	r14
 c56:	ff 92       	push	r15
 c58:	0f 93       	push	r16
 c5a:	1f 93       	push	r17
 c5c:	cf 93       	push	r28
 c5e:	df 93       	push	r29
 c60:	0f b6       	in	r0, 0x3f	; 63
 c62:	f8 94       	cli
 c64:	0f 92       	push	r0
 c66:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 c6a:	81 50       	subi	r24, 0x01	; 1
 c6c:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <uxSchedulerSuspended>
 c70:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 c74:	81 11       	cpse	r24, r1
 c76:	5f c0       	rjmp	.+190    	; 0xd36 <xTaskResumeAll+0xe6>
 c78:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxCurrentNumberOfTasks>
 c7c:	81 11       	cpse	r24, r1
 c7e:	2a c0       	rjmp	.+84     	; 0xcd4 <xTaskResumeAll+0x84>
 c80:	5d c0       	rjmp	.+186    	; 0xd3c <xTaskResumeAll+0xec>
 c82:	e0 91 27 08 	lds	r30, 0x0827	; 0x800827 <xPendingReadyList+0x7>
 c86:	f0 91 28 08 	lds	r31, 0x0828	; 0x800828 <xPendingReadyList+0x8>
 c8a:	c0 85       	ldd	r28, Z+8	; 0x08
 c8c:	d1 85       	ldd	r29, Z+9	; 0x09
 c8e:	ce 01       	movw	r24, r28
 c90:	0e 96       	adiw	r24, 0x0e	; 14
 c92:	b9 da       	rcall	.-2702   	; 0x206 <uxListRemove>
 c94:	8e 01       	movw	r16, r28
 c96:	0e 5f       	subi	r16, 0xFE	; 254
 c98:	1f 4f       	sbci	r17, 0xFF	; 255
 c9a:	c8 01       	movw	r24, r16
 c9c:	b4 da       	rcall	.-2712   	; 0x206 <uxListRemove>
 c9e:	8a 8d       	ldd	r24, Y+26	; 0x1a
 ca0:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <uxTopReadyPriority>
 ca4:	98 17       	cp	r25, r24
 ca6:	10 f4       	brcc	.+4      	; 0xcac <xTaskResumeAll+0x5c>
 ca8:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <uxTopReadyPriority>
 cac:	2b e0       	ldi	r18, 0x0B	; 11
 cae:	82 9f       	mul	r24, r18
 cb0:	c0 01       	movw	r24, r0
 cb2:	11 24       	eor	r1, r1
 cb4:	b8 01       	movw	r22, r16
 cb6:	8b 5b       	subi	r24, 0xBB	; 187
 cb8:	97 4f       	sbci	r25, 0xF7	; 247
 cba:	47 da       	rcall	.-2930   	; 0x14a <vListInsertEnd>
 cbc:	9a 8d       	ldd	r25, Y+26	; 0x1a
 cbe:	e0 91 71 08 	lds	r30, 0x0871	; 0x800871 <pxCurrentTCB>
 cc2:	f0 91 72 08 	lds	r31, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 cc6:	82 8d       	ldd	r24, Z+26	; 0x1a
 cc8:	98 17       	cp	r25, r24
 cca:	30 f0       	brcs	.+12     	; 0xcd8 <xTaskResumeAll+0x88>
 ccc:	81 e0       	ldi	r24, 0x01	; 1
 cce:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xYieldPending>
 cd2:	02 c0       	rjmp	.+4      	; 0xcd8 <xTaskResumeAll+0x88>
 cd4:	c0 e0       	ldi	r28, 0x00	; 0
 cd6:	d0 e0       	ldi	r29, 0x00	; 0
 cd8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <xPendingReadyList>
 cdc:	81 11       	cpse	r24, r1
 cde:	d1 cf       	rjmp	.-94     	; 0xc82 <xTaskResumeAll+0x32>
 ce0:	cd 2b       	or	r28, r29
 ce2:	09 f0       	breq	.+2      	; 0xce6 <xTaskResumeAll+0x96>
 ce4:	5e dc       	rcall	.-1860   	; 0x5a2 <prvResetNextTaskUnblockTime>
 ce6:	c0 90 fe 07 	lds	r12, 0x07FE	; 0x8007fe <xPendedTicks>
 cea:	d0 90 ff 07 	lds	r13, 0x07FF	; 0x8007ff <xPendedTicks+0x1>
 cee:	e0 90 00 08 	lds	r14, 0x0800	; 0x800800 <xPendedTicks+0x2>
 cf2:	f0 90 01 08 	lds	r15, 0x0801	; 0x800801 <xPendedTicks+0x3>
 cf6:	c1 14       	cp	r12, r1
 cf8:	d1 04       	cpc	r13, r1
 cfa:	e1 04       	cpc	r14, r1
 cfc:	f1 04       	cpc	r15, r1
 cfe:	a1 f0       	breq	.+40     	; 0xd28 <xTaskResumeAll+0xd8>
 d00:	cd de       	rcall	.-614    	; 0xa9c <xTaskIncrementTick>
 d02:	88 23       	and	r24, r24
 d04:	19 f0       	breq	.+6      	; 0xd0c <xTaskResumeAll+0xbc>
 d06:	81 e0       	ldi	r24, 0x01	; 1
 d08:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xYieldPending>
 d0c:	81 e0       	ldi	r24, 0x01	; 1
 d0e:	c8 1a       	sub	r12, r24
 d10:	d1 08       	sbc	r13, r1
 d12:	e1 08       	sbc	r14, r1
 d14:	f1 08       	sbc	r15, r1
 d16:	a1 f7       	brne	.-24     	; 0xd00 <xTaskResumeAll+0xb0>
 d18:	10 92 fe 07 	sts	0x07FE, r1	; 0x8007fe <xPendedTicks>
 d1c:	10 92 ff 07 	sts	0x07FF, r1	; 0x8007ff <xPendedTicks+0x1>
 d20:	10 92 00 08 	sts	0x0800, r1	; 0x800800 <xPendedTicks+0x2>
 d24:	10 92 01 08 	sts	0x0801, r1	; 0x800801 <xPendedTicks+0x3>
 d28:	80 91 fd 07 	lds	r24, 0x07FD	; 0x8007fd <xYieldPending>
 d2c:	88 23       	and	r24, r24
 d2e:	29 f0       	breq	.+10     	; 0xd3a <xTaskResumeAll+0xea>
 d30:	39 db       	rcall	.-2446   	; 0x3a4 <vPortYield>
 d32:	81 e0       	ldi	r24, 0x01	; 1
 d34:	03 c0       	rjmp	.+6      	; 0xd3c <xTaskResumeAll+0xec>
 d36:	80 e0       	ldi	r24, 0x00	; 0
 d38:	01 c0       	rjmp	.+2      	; 0xd3c <xTaskResumeAll+0xec>
 d3a:	80 e0       	ldi	r24, 0x00	; 0
 d3c:	0f 90       	pop	r0
 d3e:	0f be       	out	0x3f, r0	; 63
 d40:	df 91       	pop	r29
 d42:	cf 91       	pop	r28
 d44:	1f 91       	pop	r17
 d46:	0f 91       	pop	r16
 d48:	ff 90       	pop	r15
 d4a:	ef 90       	pop	r14
 d4c:	df 90       	pop	r13
 d4e:	cf 90       	pop	r12
 d50:	08 95       	ret

00000d52 <vTaskDelay>:
 d52:	cf 92       	push	r12
 d54:	df 92       	push	r13
 d56:	ef 92       	push	r14
 d58:	ff 92       	push	r15
 d5a:	6b 01       	movw	r12, r22
 d5c:	7c 01       	movw	r14, r24
 d5e:	67 2b       	or	r22, r23
 d60:	68 2b       	or	r22, r24
 d62:	69 2b       	or	r22, r25
 d64:	39 f0       	breq	.+14     	; 0xd74 <vTaskDelay+0x22>
 d66:	94 de       	rcall	.-728    	; 0xa90 <vTaskSuspendAll>
 d68:	40 e0       	ldi	r20, 0x00	; 0
 d6a:	c7 01       	movw	r24, r14
 d6c:	b6 01       	movw	r22, r12
 d6e:	65 dd       	rcall	.-1334   	; 0x83a <prvAddCurrentTaskToDelayedList>
 d70:	6f df       	rcall	.-290    	; 0xc50 <xTaskResumeAll>
 d72:	01 c0       	rjmp	.+2      	; 0xd76 <vTaskDelay+0x24>
 d74:	80 e0       	ldi	r24, 0x00	; 0
 d76:	81 11       	cpse	r24, r1
 d78:	01 c0       	rjmp	.+2      	; 0xd7c <vTaskDelay+0x2a>
 d7a:	14 db       	rcall	.-2520   	; 0x3a4 <vPortYield>
 d7c:	ff 90       	pop	r15
 d7e:	ef 90       	pop	r14
 d80:	df 90       	pop	r13
 d82:	cf 90       	pop	r12
 d84:	08 95       	ret

00000d86 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d86:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 d8a:	88 23       	and	r24, r24
 d8c:	21 f0       	breq	.+8      	; 0xd96 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d8e:	81 e0       	ldi	r24, 0x01	; 1
 d90:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xYieldPending>
 d94:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d96:	10 92 fd 07 	sts	0x07FD, r1	; 0x8007fd <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 d9a:	80 91 03 08 	lds	r24, 0x0803	; 0x800803 <uxTopReadyPriority>
 d9e:	01 c0       	rjmp	.+2      	; 0xda2 <vTaskSwitchContext+0x1c>
 da0:	81 50       	subi	r24, 0x01	; 1
 da2:	28 2f       	mov	r18, r24
 da4:	30 e0       	ldi	r19, 0x00	; 0
 da6:	9b e0       	ldi	r25, 0x0B	; 11
 da8:	92 9f       	mul	r25, r18
 daa:	f0 01       	movw	r30, r0
 dac:	93 9f       	mul	r25, r19
 dae:	f0 0d       	add	r31, r0
 db0:	11 24       	eor	r1, r1
 db2:	eb 5b       	subi	r30, 0xBB	; 187
 db4:	f7 4f       	sbci	r31, 0xF7	; 247
 db6:	90 81       	ld	r25, Z
 db8:	99 23       	and	r25, r25
 dba:	91 f3       	breq	.-28     	; 0xda0 <vTaskSwitchContext+0x1a>
 dbc:	9b e0       	ldi	r25, 0x0B	; 11
 dbe:	92 9f       	mul	r25, r18
 dc0:	a0 01       	movw	r20, r0
 dc2:	93 9f       	mul	r25, r19
 dc4:	50 0d       	add	r21, r0
 dc6:	11 24       	eor	r1, r1
 dc8:	df 01       	movw	r26, r30
 dca:	01 80       	ldd	r0, Z+1	; 0x01
 dcc:	f2 81       	ldd	r31, Z+2	; 0x02
 dce:	e0 2d       	mov	r30, r0
 dd0:	04 80       	ldd	r0, Z+4	; 0x04
 dd2:	f5 81       	ldd	r31, Z+5	; 0x05
 dd4:	e0 2d       	mov	r30, r0
 dd6:	12 96       	adiw	r26, 0x02	; 2
 dd8:	fc 93       	st	X, r31
 dda:	ee 93       	st	-X, r30
 ddc:	11 97       	sbiw	r26, 0x01	; 1
 dde:	48 5b       	subi	r20, 0xB8	; 184
 de0:	57 4f       	sbci	r21, 0xF7	; 247
 de2:	e4 17       	cp	r30, r20
 de4:	f5 07       	cpc	r31, r21
 de6:	29 f4       	brne	.+10     	; 0xdf2 <vTaskSwitchContext+0x6c>
 de8:	44 81       	ldd	r20, Z+4	; 0x04
 dea:	55 81       	ldd	r21, Z+5	; 0x05
 dec:	fd 01       	movw	r30, r26
 dee:	52 83       	std	Z+2, r21	; 0x02
 df0:	41 83       	std	Z+1, r20	; 0x01
 df2:	9b e0       	ldi	r25, 0x0B	; 11
 df4:	92 9f       	mul	r25, r18
 df6:	f0 01       	movw	r30, r0
 df8:	93 9f       	mul	r25, r19
 dfa:	f0 0d       	add	r31, r0
 dfc:	11 24       	eor	r1, r1
 dfe:	eb 5b       	subi	r30, 0xBB	; 187
 e00:	f7 4f       	sbci	r31, 0xF7	; 247
 e02:	01 80       	ldd	r0, Z+1	; 0x01
 e04:	f2 81       	ldd	r31, Z+2	; 0x02
 e06:	e0 2d       	mov	r30, r0
 e08:	20 85       	ldd	r18, Z+8	; 0x08
 e0a:	31 85       	ldd	r19, Z+9	; 0x09
 e0c:	30 93 72 08 	sts	0x0872, r19	; 0x800872 <pxCurrentTCB+0x1>
 e10:	20 93 71 08 	sts	0x0871, r18	; 0x800871 <pxCurrentTCB>
 e14:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <uxTopReadyPriority>
 e18:	08 95       	ret

00000e1a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 e1a:	0f 93       	push	r16
 e1c:	1f 93       	push	r17
 e1e:	cf 93       	push	r28
 e20:	df 93       	push	r29
 e22:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 e24:	0f b6       	in	r0, 0x3f	; 63
 e26:	f8 94       	cli
 e28:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 e2a:	89 2b       	or	r24, r25
 e2c:	21 f4       	brne	.+8      	; 0xe36 <vTaskSuspend+0x1c>
 e2e:	c0 91 71 08 	lds	r28, 0x0871	; 0x800871 <pxCurrentTCB>
 e32:	d0 91 72 08 	lds	r29, 0x0872	; 0x800872 <pxCurrentTCB+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 e36:	8e 01       	movw	r16, r28
 e38:	0e 5f       	subi	r16, 0xFE	; 254
 e3a:	1f 4f       	sbci	r17, 0xFF	; 255
 e3c:	c8 01       	movw	r24, r16
 e3e:	e3 d9       	rcall	.-3130   	; 0x206 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 e40:	88 8d       	ldd	r24, Y+24	; 0x18
 e42:	99 8d       	ldd	r25, Y+25	; 0x19
 e44:	89 2b       	or	r24, r25
 e46:	19 f0       	breq	.+6      	; 0xe4e <vTaskSuspend+0x34>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 e48:	ce 01       	movw	r24, r28
 e4a:	0e 96       	adiw	r24, 0x0e	; 14
 e4c:	dc d9       	rcall	.-3144   	; 0x206 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 e4e:	b8 01       	movw	r22, r16
 e50:	89 e0       	ldi	r24, 0x09	; 9
 e52:	98 e0       	ldi	r25, 0x08	; 8
 e54:	7a d9       	rcall	.-3340   	; 0x14a <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 e56:	89 a5       	ldd	r24, Y+41	; 0x29
 e58:	81 30       	cpi	r24, 0x01	; 1
 e5a:	09 f4       	brne	.+2      	; 0xe5e <vTaskSuspend+0x44>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 e5c:	19 a6       	std	Y+41, r1	; 0x29
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 e5e:	0f 90       	pop	r0
 e60:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
 e62:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xSchedulerRunning>
 e66:	88 23       	and	r24, r24
 e68:	31 f0       	breq	.+12     	; 0xe76 <vTaskSuspend+0x5c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 e6a:	0f b6       	in	r0, 0x3f	; 63
 e6c:	f8 94       	cli
			{
				prvResetNextTaskUnblockTime();
 e6e:	0f 92       	push	r0
 e70:	98 db       	rcall	.-2256   	; 0x5a2 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 e72:	0f 90       	pop	r0
 e74:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 e76:	80 91 71 08 	lds	r24, 0x0871	; 0x800871 <pxCurrentTCB>
 e7a:	90 91 72 08 	lds	r25, 0x0872	; 0x800872 <pxCurrentTCB+0x1>
 e7e:	c8 17       	cp	r28, r24
 e80:	d9 07       	cpc	r29, r25
 e82:	91 f4       	brne	.+36     	; 0xea8 <vTaskSuspend+0x8e>
		{
			if( xSchedulerRunning != pdFALSE )
 e84:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xSchedulerRunning>
 e88:	88 23       	and	r24, r24
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 e8a:	11 f0       	breq	.+4      	; 0xe90 <vTaskSuspend+0x76>
 e8c:	8b da       	rcall	.-2794   	; 0x3a4 <vPortYield>
 e8e:	0c c0       	rjmp	.+24     	; 0xea8 <vTaskSuspend+0x8e>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 e90:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <xSuspendedTaskList>
 e94:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxCurrentNumberOfTasks>
 e98:	98 13       	cpse	r25, r24
 e9a:	05 c0       	rjmp	.+10     	; 0xea6 <vTaskSuspend+0x8c>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 e9c:	10 92 72 08 	sts	0x0872, r1	; 0x800872 <pxCurrentTCB+0x1>
 ea0:	10 92 71 08 	sts	0x0871, r1	; 0x800871 <pxCurrentTCB>
				}
				else
				{
					vTaskSwitchContext();
 ea4:	01 c0       	rjmp	.+2      	; 0xea8 <vTaskSuspend+0x8e>
 ea6:	6f df       	rcall	.-290    	; 0xd86 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 ea8:	df 91       	pop	r29
 eaa:	cf 91       	pop	r28
 eac:	1f 91       	pop	r17
 eae:	0f 91       	pop	r16
 eb0:	08 95       	ret

00000eb2 <main>:
#include "vers/version.h"


int main(void)
{
	taskInit();
 eb2:	58 d0       	rcall	.+176    	; 0xf64 <taskInit>
 	vTaskStartScheduler();
 eb4:	bc dd       	rcall	.-1160   	; 0xa2e <vTaskStartScheduler>
 eb6:	ff cf       	rjmp	.-2      	; 0xeb6 <main+0x4>

00000eb8 <task_blinkLedRed>:
 eb8:	e2 e0       	ldi	r30, 0x02	; 2
void task_blinkLedRed(void *p)
{
	while(1)
	{
		//Toggle Pin to create blink activity
		BitToggle(DEBUG_LED_PORT, RED_LED);
 eba:	f1 e0       	ldi	r31, 0x01	; 1
 ebc:	90 81       	ld	r25, Z
 ebe:	80 e1       	ldi	r24, 0x10	; 16
 ec0:	89 27       	eor	r24, r25
 ec2:	80 83       	st	Z, r24
		
		//vTaskDelay() is a generic delays which will offer at the ticks passed to the function, it won't be accurate.
		vTaskDelay(pdMS_TO_TICKS(250));
 ec4:	6a ef       	ldi	r22, 0xFA	; 250
 ec6:	70 e0       	ldi	r23, 0x00	; 0
 ec8:	80 e0       	ldi	r24, 0x00	; 0
 eca:	90 e0       	ldi	r25, 0x00	; 0
 ecc:	42 df       	rcall	.-380    	; 0xd52 <vTaskDelay>
 ece:	f4 cf       	rjmp	.-24     	; 0xeb8 <task_blinkLedRed>

00000ed0 <task_blinkLedGreen>:
void task_blinkLedGreen(void *p)
{
	while(1)
	{
		//vTaskDelay() is a generic delays which will offer at the ticks passed to the function, it won't be accurate.
		vTaskDelay(pdMS_TO_TICKS(3000));
 ed0:	68 eb       	ldi	r22, 0xB8	; 184
 ed2:	7b e0       	ldi	r23, 0x0B	; 11
 ed4:	80 e0       	ldi	r24, 0x00	; 0
 ed6:	90 e0       	ldi	r25, 0x00	; 0
 ed8:	3c df       	rcall	.-392    	; 0xd52 <vTaskDelay>

		vTaskSuspend(blinkLedRed_task1Handle);
 eda:	80 91 77 08 	lds	r24, 0x0877	; 0x800877 <blinkLedRed_task1Handle>
 ede:	90 91 78 08 	lds	r25, 0x0878	; 0x800878 <blinkLedRed_task1Handle+0x1>
 ee2:	9b df       	rcall	.-202    	; 0xe1a <vTaskSuspend>
		BitSet(DEBUG_LED_PORT, RED_LED);
 ee4:	e2 e0       	ldi	r30, 0x02	; 2
 ee6:	f1 e0       	ldi	r31, 0x01	; 1
 ee8:	80 81       	ld	r24, Z
 eea:	80 61       	ori	r24, 0x10	; 16
 eec:	80 83       	st	Z, r24

		for(uint8_t i = 0; i < 12; i++)
 eee:	c0 e0       	ldi	r28, 0x00	; 0
 ef0:	0c c0       	rjmp	.+24     	; 0xf0a <task_blinkLedGreen+0x3a>
		{
			//Toggle Pin to create blink activity
			BitToggle(DEBUG_LED_PORT, GREEN_LED);
 ef2:	e2 e0       	ldi	r30, 0x02	; 2
 ef4:	f1 e0       	ldi	r31, 0x01	; 1
 ef6:	90 81       	ld	r25, Z
 ef8:	80 e2       	ldi	r24, 0x20	; 32
 efa:	89 27       	eor	r24, r25
 efc:	80 83       	st	Z, r24
			vTaskDelay(pdMS_TO_TICKS(250));
 efe:	6a ef       	ldi	r22, 0xFA	; 250
 f00:	70 e0       	ldi	r23, 0x00	; 0
 f02:	80 e0       	ldi	r24, 0x00	; 0
 f04:	90 e0       	ldi	r25, 0x00	; 0
 f06:	25 df       	rcall	.-438    	; 0xd52 <vTaskDelay>
		vTaskDelay(pdMS_TO_TICKS(3000));

		vTaskSuspend(blinkLedRed_task1Handle);
		BitSet(DEBUG_LED_PORT, RED_LED);

		for(uint8_t i = 0; i < 12; i++)
 f08:	cf 5f       	subi	r28, 0xFF	; 255
 f0a:	cc 30       	cpi	r28, 0x0C	; 12
 f0c:	90 f3       	brcs	.-28     	; 0xef2 <task_blinkLedGreen+0x22>
 f0e:	e0 cf       	rjmp	.-64     	; 0xed0 <task_blinkLedGreen>

00000f10 <task_blinkLedBlue>:
void task_blinkLedBlue(void *p)
{	
	while(1)
	{
		//vTaskDelay() is a generic delays which will offer at the ticks passed to the function, it won't be accurate.
		vTaskDelay(pdMS_TO_TICKS(6000));
 f10:	60 e7       	ldi	r22, 0x70	; 112
 f12:	77 e1       	ldi	r23, 0x17	; 23
 f14:	80 e0       	ldi	r24, 0x00	; 0
 f16:	90 e0       	ldi	r25, 0x00	; 0
 f18:	1c df       	rcall	.-456    	; 0xd52 <vTaskDelay>

		vTaskSuspend(blinkLedGreen_task2Handle);
 f1a:	80 91 75 08 	lds	r24, 0x0875	; 0x800875 <blinkLedGreen_task2Handle>
 f1e:	90 91 76 08 	lds	r25, 0x0876	; 0x800876 <blinkLedGreen_task2Handle+0x1>
 f22:	7b df       	rcall	.-266    	; 0xe1a <vTaskSuspend>
		BitSet(DEBUG_LED_PORT, GREEN_LED);
 f24:	e2 e0       	ldi	r30, 0x02	; 2
 f26:	f1 e0       	ldi	r31, 0x01	; 1
 f28:	80 81       	ld	r24, Z
 f2a:	80 62       	ori	r24, 0x20	; 32
 f2c:	80 83       	st	Z, r24

		for(uint8_t i = 0; i < 12; i++)
 f2e:	c0 e0       	ldi	r28, 0x00	; 0
 f30:	0c c0       	rjmp	.+24     	; 0xf4a <task_blinkLedBlue+0x3a>
		{
			//Toggle Pin to create blink activity
			BitToggle(DEBUG_LED_PORT, BLUE_LED);
 f32:	e2 e0       	ldi	r30, 0x02	; 2
 f34:	f1 e0       	ldi	r31, 0x01	; 1
 f36:	90 81       	ld	r25, Z
 f38:	88 e0       	ldi	r24, 0x08	; 8
 f3a:	89 27       	eor	r24, r25
 f3c:	80 83       	st	Z, r24
			vTaskDelay(pdMS_TO_TICKS(250));
 f3e:	6a ef       	ldi	r22, 0xFA	; 250
 f40:	70 e0       	ldi	r23, 0x00	; 0
 f42:	80 e0       	ldi	r24, 0x00	; 0
 f44:	90 e0       	ldi	r25, 0x00	; 0
 f46:	05 df       	rcall	.-502    	; 0xd52 <vTaskDelay>
		vTaskDelay(pdMS_TO_TICKS(6000));

		vTaskSuspend(blinkLedGreen_task2Handle);
		BitSet(DEBUG_LED_PORT, GREEN_LED);

		for(uint8_t i = 0; i < 12; i++)
 f48:	cf 5f       	subi	r28, 0xFF	; 255
 f4a:	cc 30       	cpi	r28, 0x0C	; 12
 f4c:	90 f3       	brcs	.-28     	; 0xf32 <task_blinkLedBlue+0x22>
			//Toggle Pin to create blink activity
			BitToggle(DEBUG_LED_PORT, BLUE_LED);
			vTaskDelay(pdMS_TO_TICKS(250));
		}
		
		vTaskResume(blinkLedRed_task1Handle);
 f4e:	80 91 77 08 	lds	r24, 0x0877	; 0x800877 <blinkLedRed_task1Handle>
 f52:	90 91 78 08 	lds	r25, 0x0878	; 0x800878 <blinkLedRed_task1Handle+0x1>
 f56:	33 dd       	rcall	.-1434   	; 0x9be <vTaskResume>
		vTaskResume(blinkLedGreen_task2Handle);
 f58:	80 91 75 08 	lds	r24, 0x0875	; 0x800875 <blinkLedGreen_task2Handle>
 f5c:	90 91 76 08 	lds	r25, 0x0876	; 0x800876 <blinkLedGreen_task2Handle+0x1>
 f60:	2e dd       	rcall	.-1444   	; 0x9be <vTaskResume>
	}
 f62:	d6 cf       	rjmp	.-84     	; 0xf10 <task_blinkLedBlue>

00000f64 <taskInit>:
TaskHandle_t blinkLedGreen_task2Handle = NULL;
TaskHandle_t blinkLedBlue_task3Handle = NULL;
/****************************/

void taskInit(void)
{
 f64:	ef 92       	push	r14
 f66:	ff 92       	push	r15
 f68:	0f 93       	push	r16
	//Set pins as output
	BitSet(DEBUG_LED_DDR, RED_LED);
 f6a:	e1 e0       	ldi	r30, 0x01	; 1
 f6c:	f1 e0       	ldi	r31, 0x01	; 1
 f6e:	80 81       	ld	r24, Z
 f70:	80 61       	ori	r24, 0x10	; 16
 f72:	80 83       	st	Z, r24
	BitSet(DEBUG_LED_DDR, GREEN_LED);
 f74:	80 81       	ld	r24, Z
 f76:	80 62       	ori	r24, 0x20	; 32
 f78:	80 83       	st	Z, r24
	BitSet(DEBUG_LED_DDR, BLUE_LED);
 f7a:	80 81       	ld	r24, Z
 f7c:	88 60       	ori	r24, 0x08	; 8
 f7e:	80 83       	st	Z, r24
	
	//Active Low signals
	BitSet(DEBUG_LED_PORT,RED_LED);
 f80:	e2 e0       	ldi	r30, 0x02	; 2
 f82:	f1 e0       	ldi	r31, 0x01	; 1
 f84:	80 81       	ld	r24, Z
 f86:	80 61       	ori	r24, 0x10	; 16
 f88:	80 83       	st	Z, r24
	BitSet(DEBUG_LED_PORT,GREEN_LED);
 f8a:	80 81       	ld	r24, Z
 f8c:	80 62       	ori	r24, 0x20	; 32
 f8e:	80 83       	st	Z, r24
	BitSet(DEBUG_LED_PORT,BLUE_LED);
 f90:	80 81       	ld	r24, Z
 f92:	88 60       	ori	r24, 0x08	; 8
 f94:	80 83       	st	Z, r24
	
	//Task Creation
	xTaskCreate(task_blinkLedRed,	"Red",		configMINIMAL_STACK_SIZE,(void*) 0, blinkLED_TASK_PRIORITY, &blinkLedRed_task1Handle);
 f96:	0f 2e       	mov	r0, r31
 f98:	f7 e7       	ldi	r31, 0x77	; 119
 f9a:	ef 2e       	mov	r14, r31
 f9c:	f8 e0       	ldi	r31, 0x08	; 8
 f9e:	ff 2e       	mov	r15, r31
 fa0:	f0 2d       	mov	r31, r0
 fa2:	00 e0       	ldi	r16, 0x00	; 0
 fa4:	20 e0       	ldi	r18, 0x00	; 0
 fa6:	30 e0       	ldi	r19, 0x00	; 0
 fa8:	45 e5       	ldi	r20, 0x55	; 85
 faa:	50 e0       	ldi	r21, 0x00	; 0
 fac:	65 e0       	ldi	r22, 0x05	; 5
 fae:	72 e0       	ldi	r23, 0x02	; 2
 fb0:	8c e5       	ldi	r24, 0x5C	; 92
 fb2:	97 e0       	ldi	r25, 0x07	; 7
 fb4:	b5 dc       	rcall	.-1686   	; 0x920 <xTaskCreate>
	xTaskCreate(task_blinkLedGreen, "Green",	configMINIMAL_STACK_SIZE,(void*) 0, blinkLED_TASK_PRIORITY, &blinkLedGreen_task2Handle);
 fb6:	0f 2e       	mov	r0, r31
 fb8:	f5 e7       	ldi	r31, 0x75	; 117
 fba:	ef 2e       	mov	r14, r31
 fbc:	f8 e0       	ldi	r31, 0x08	; 8
 fbe:	ff 2e       	mov	r15, r31
 fc0:	f0 2d       	mov	r31, r0
 fc2:	20 e0       	ldi	r18, 0x00	; 0
 fc4:	30 e0       	ldi	r19, 0x00	; 0
 fc6:	45 e5       	ldi	r20, 0x55	; 85
 fc8:	50 e0       	ldi	r21, 0x00	; 0
 fca:	69 e0       	ldi	r22, 0x09	; 9
 fcc:	72 e0       	ldi	r23, 0x02	; 2
 fce:	88 e6       	ldi	r24, 0x68	; 104
 fd0:	97 e0       	ldi	r25, 0x07	; 7
 fd2:	a6 dc       	rcall	.-1716   	; 0x920 <xTaskCreate>
	xTaskCreate(task_blinkLedBlue,	"Blue",		configMINIMAL_STACK_SIZE,(void*) 0, blinkLED_TASK_PRIORITY, &blinkLedBlue_task3Handle);
 fd4:	0f 2e       	mov	r0, r31
 fd6:	f3 e7       	ldi	r31, 0x73	; 115
 fd8:	ef 2e       	mov	r14, r31
 fda:	f8 e0       	ldi	r31, 0x08	; 8
 fdc:	ff 2e       	mov	r15, r31
 fde:	f0 2d       	mov	r31, r0
 fe0:	20 e0       	ldi	r18, 0x00	; 0
 fe2:	30 e0       	ldi	r19, 0x00	; 0
 fe4:	45 e5       	ldi	r20, 0x55	; 85
 fe6:	50 e0       	ldi	r21, 0x00	; 0
 fe8:	6f e0       	ldi	r22, 0x0F	; 15
 fea:	72 e0       	ldi	r23, 0x02	; 2
 fec:	88 e8       	ldi	r24, 0x88	; 136
 fee:	97 e0       	ldi	r25, 0x07	; 7
 ff0:	97 dc       	rcall	.-1746   	; 0x920 <xTaskCreate>
}
 ff2:	0f 91       	pop	r16
 ff4:	ff 90       	pop	r15
 ff6:	ef 90       	pop	r14
 ff8:	08 95       	ret

00000ffa <_exit>:
 ffa:	f8 94       	cli

00000ffc <__stop_program>:
 ffc:	ff cf       	rjmp	.-2      	; 0xffc <__stop_program>
